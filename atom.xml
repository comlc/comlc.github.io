<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>COMLCのBlog</title>
  
  <subtitle>Live beautifully, dream passionately, love completely</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://comlc.github.io/"/>
  <updated>2020-03-21T09:56:30.627Z</updated>
  <id>https://comlc.github.io/</id>
  
  <author>
    <name>comlc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Skywalking编译与部署</title>
    <link href="https://comlc.github.io/2019/10/20/APM%E5%85%A8%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/"/>
    <id>https://comlc.github.io/2019/10/20/APM全链路监控/</id>
    <published>2019-10-20T03:00:00.000Z</published>
    <updated>2020-03-21T09:56:30.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>APM(Application Performance Management)即应用性能管理。主要解决分布式调用链分析难，以及性能优化无从下手的问题。</p><a id="more"></a><h2 id="APM工具介绍"><a href="#APM工具介绍" class="headerlink" title="APM工具介绍"></a>APM工具介绍</h2><blockquote><p>比较常见的APM工具有Pinpoint、SkyWalking、Zipkin、CAT。Pinpoint和SkyWalking基使用java探针，字节码增强；CAT是通过代码埋点（拦截器，注解，过滤器等）；Zipkin是拦截请求发送（HTTP，mq）数据至zipkin服务  </p></blockquote><h2 id="Skywalking介绍"><a href="#Skywalking介绍" class="headerlink" title="Skywalking介绍"></a>Skywalking介绍</h2><p><img src="/2019/10/20/APM全链路监控/../../../../img/skywalking/img1.png" alt="Skywalking技术架构"></p><ol><li>Skywalking Agent：使用JavaAgent做字节码植入，无侵入式的收集，并通过HTTP或者gRPC方式发送数据到Skywalking Collector。</li><li>Skywalking Collector ：链路数据收集器，对agent传过来的数据进行整合分析处理并落入相关的数据存储中。</li><li>Storage：Skywalking的存储，时间更迭，sw已经开发迭代到了6.x版本，在6.x版本中支持以ElasticSearch、Mysql、TiDB、H2、作为存储介质进行数据存储。</li><li>UI：Web可视化平台，用来展示落地的数据。</li></ol><h2 id="Skywalking功能"><a href="#Skywalking功能" class="headerlink" title="Skywalking功能"></a>Skywalking功能</h2><ol><li>Service Topology监控，提供系统的拓扑图，从整体上各个系统之间调用关系。</li><li>Skywalking Trace监控，通过业务调用监控进行依赖分析，提供给我们了服务之间的服务调用拓扑关系、以及针对每个endpoint的trace记录，每一条trace的信息中都可以看到当前请求的时间、GloableId、以及请求被调用的时间。</li><li>Skywalking性能监控，从应用整体外部来看我们可以监测到应用在一定时间段内的，平均响应时间、服务可用性指标SLA等指标。</li><li>Service JVM信息监控，可以监控到Service运行时的CPU、堆内存、非堆内存使用率、以及GC情况。</li><li>Skywalking服务告警，通过<code>alarm-settings.xml</code>配置告警规则。</li></ol><h2 id="Skywalking-Collector"><a href="#Skywalking-Collector" class="headerlink" title="Skywalking Collector"></a>Skywalking Collector</h2><ol><li>源码可以在GitHub下载<a href="https://github.com/apache/skywalking/" target="_blank" rel="noopener">https://github.com/apache/skywalking/</a>。</li><li>将相应模块导入到Idea中，链路数据收集器对应项目中的oap-server，Agent对应apm-sniffer，UI对应skywalking-ui，我将UI项目单独作为VUE项目导入了，项目结构如下图：<br><img src="/2019/10/20/APM全链路监控/../../../../img/skywalking/img2.png" alt="Skywalking项目结构"></li><li>oap-server模块中主要看server-starter和server-bootstrap模块，server-bootstrap模块主要是初始化整个收集器服务，可以在application.yml中修改存储等配置，这里我使用mysql存储。</li><li>server-starter是收集器服务的执行入口，编译模块，执行OAPServerStartUp即可启动服务。</li></ol><h2 id="Skywalking-Agent"><a href="#Skywalking-Agent" class="headerlink" title="Skywalking Agent"></a>Skywalking Agent</h2><ol><li>apm-sniffer模块中主模块是apm-agent，该模块是通过<code>maven-antrun-plugin</code>插件，在Maven内运行Ant任务将项目打包输出，可在agent.config中修改相关配置。打包输出结果skywalking-agent目录如下图：<br><img src="/2019/10/20/APM全链路监控/../../../../img/skywalking/img3.png" alt="Agent编译输出"></li><li>由于Agent是非侵入式的，所以只需在运行项目时加上<code>-Dskywalking.agent.service_name=ums-service -Dskywalking.collector.backend_service=localhost:11800 -javaagent:D:/skywalking-agent.jar</code>，<br>如可在Idea中<code>Edit Configurations</code>中配置<code>VM options</code>。</li></ol><h2 id="Skywalking-UI"><a href="#Skywalking-UI" class="headerlink" title="Skywalking UI"></a>Skywalking UI</h2><ol><li>skywalking-ui是一个VUE项目，导入到Idea后，执行<code>npm install</code>安装所需组件，项目结构如下图：<br><img src="/2019/10/20/APM全链路监控/../../../../img/skywalking/img4.png" alt="UI项目结构"></li><li>可在vue.config.js中修改收集器服务地址等，执行<code>npm run serve</code>，在启动项目过程中可能会遇到<code>npm ERR! code ELIFECYCLE</code>错误，最终通过重新安装新版NodeJS解决了问题。</li></ol><h2 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h2><ol><li><p>oap-server使用<code>maven-assembly-plugin</code>插件打包，再使用<code>dockerfile-maven-plugin</code>插件远程build镜像。pom.xml相关配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>skywalking-oap<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptors</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptor</span>&gt;</span>src/main/assembly/assembly.xml<span class="tag">&lt;/<span class="name">descriptor</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dockerfile-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--如果package时不想用docker打包,就注释掉这个goal--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>default<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>build<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>push<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--docker私服地址--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">repository</span>&gt;</span>skywalking-oap<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">useMavenSettingsForAuth</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useMavenSettingsForAuth</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">username</span>&gt;</span>comlc<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">password</span>&gt;</span>comlc<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">tag</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">tag</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">contextDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/skywalking-oap-assembly/skywalking-oap<span class="tag">&lt;/<span class="name">contextDirectory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">OAP_CONFIG</span>&gt;</span>config<span class="tag">&lt;/<span class="name">OAP_CONFIG</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">OAP_LIBS</span>&gt;</span>oap-libs<span class="tag">&lt;/<span class="name">OAP_LIBS</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">buildArgs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>assembly.xml相关配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">assembly</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.2 http://maven.apache.org/xsd/assembly-1.1.2.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">formats</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">format</span>&gt;</span>dir<span class="tag">&lt;/<span class="name">format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">formats</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fileSets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/src/main/docker<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>/<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileSet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.basedir&#125;/../server-bootstrap/src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>/config<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">fileSet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fileSets</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencySets</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>/oap-libs<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencySet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencySets</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Dockerfile相关配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8u181-jdk-stretch</span><br><span class="line"></span><br><span class="line">ENV JAVA_OPTS=" -Xms256M "</span><br><span class="line"></span><br><span class="line">ARG OAP_CONFIG</span><br><span class="line">ARG OAP_LIBS</span><br><span class="line"></span><br><span class="line">WORKDIR skywalking</span><br><span class="line"></span><br><span class="line">COPY $&#123;OAP_CONFIG&#125; config/</span><br><span class="line">COPY $&#123;OAP_LIBS&#125; oap-libs/</span><br><span class="line">COPY docker-entrypoint.sh .</span><br><span class="line"></span><br><span class="line">RUN mkdir ext-config; \</span><br><span class="line">    mkdir ext-libs;</span><br><span class="line"></span><br><span class="line">EXPOSE 12800 11800</span><br><span class="line"></span><br><span class="line">ENTRYPOINT ["bash", "docker-entrypoint.sh"]</span><br></pre></td></tr></table></figure></li><li><p>docker-entrypoint.sh相关配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">set -e</span><br><span class="line"></span><br><span class="line">echo "[Entrypoint] Apache SkyWalking Docker Image"</span><br><span class="line"></span><br><span class="line">OAP_LIB_DIR=/skywalking/oap-libs</span><br><span class="line">EXT_LIB_DIR=/skywalking/ext-libs</span><br><span class="line">EXT_CONFIG_DIR=/skywalking/ext-config</span><br><span class="line"></span><br><span class="line">CLASSPATH="config:$CLASSPATH"</span><br><span class="line">for i in $&#123;OAP_LIB_DIR&#125;/*.jar</span><br><span class="line">do</span><br><span class="line">    CLASSPATH="$i:$CLASSPATH"</span><br><span class="line">done</span><br><span class="line">for i in $&#123;EXT_LIB_DIR&#125;/*.jar</span><br><span class="line">do</span><br><span class="line">    CLASSPATH="$i:$CLASSPATH"</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">set -ex</span><br><span class="line">exec java -XX:+UnlockExperimentalVMOptions -XX:+UseCGroupMemoryLimitForHeap -Duser.timezone=GMT+08 \</span><br><span class="line">     $&#123;JAVA_OPTS&#125; -classpath $&#123;CLASSPATH&#125; org.apache.skywalking.oap.server.starter.OAPServerStartUp "$@"</span><br></pre></td></tr></table></figure></li><li><p>maven重新打包，会输出skywalking-oap-assembly目录，并远程构建镜像，如下图：<br><img src="/2019/10/20/APM全链路监控/../../../../img/skywalking/img5.png" alt="oap-server输出"></p></li><li>到Docker服务端，执行<code>docker images</code>会看到<code>skywalking-oap</code>镜像，执行<code>docker run --name skywalking-oap --restart=always -v /etc/localtime:/etc/localtime -p 12800:12800 -p 11800:11800 -d skywalking-oap:6.6.0</code>启动容器。</li></ol><h2 id="Skywalking的远程调试"><a href="#Skywalking的远程调试" class="headerlink" title="Skywalking的远程调试"></a>Skywalking的远程调试</h2><ol><li>使用Idea配置远程调试，可选择配置调试<code>oap-server</code>或<code>apm-sniffer</code>，这里以oap-server`为例，端口配远程机器上没有被占用的即可，如下图：<br><img src="/2019/10/20/APM全链路监控/../../../../img/skywalking/img6.png" alt="远程调试配置"></li><li>修改<code>docker-entrypoint.sh</code>配置，在运行收集器服务入口处加上<code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</code>，重新生成镜像并启动容器。</li><li>在Idea上运行配置的<code>oap-remote-debug</code>，显示<code>Connected to the target VM, address: &#39;192.168.2.102:5005&#39;, transport: &#39;socket&#39;</code>说明连接成功。</li></ol><h2 id="Docker时区问题"><a href="#Docker时区问题" class="headerlink" title="Docker时区问题"></a>Docker时区问题</h2><ol><li>收集器服务跑在Docker上的时候，发现部分数据查不到，如当前服务实例，但查看数据库`service_inventory表中又是有数据的，在本机启动服务就没啥问题。</li><li><p>经过远程调试查询接口后，发现是Java根据时间间隔取起止时间戳的时候与本机运行的时候不一样，导致条件查询查不到数据，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Service&gt; <span class="title">searchServices</span><span class="params">(<span class="keyword">final</span> Duration duration, <span class="keyword">final</span> String keyword)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ParseException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = DurationUtils.INSTANCE.startTimeToTimestamp(duration.getStep(), duration.getStart());</span><br><span class="line">    <span class="keyword">long</span> endTimestamp = DurationUtils.INSTANCE.endTimeToTimestamp(duration.getStep(), duration.getEnd());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getMetadataQueryService().searchServices(startTimestamp, endTimestamp, keyword);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行<code>date</code>查看了宿主机和Docker的时区信息，宿主机是CST，而Docker是UTC，修改Docker时区与宿主机一致：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.在run容器时添加参数挂载宿主时间配置：-v /etc/localtime:/etc/localtime</span><br><span class="line">2.复制宿主localtime时间配置覆盖：docker cp /etc/localtime container_id:/etc/localtime</span><br><span class="line">3.在启动jar包添加时区参数：-Duser.timezone=GMT+08</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;APM(Application Performance Management)即应用性能管理。主要解决分布式调用链分析难，以及性能优化无从下手的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务" scheme="https://comlc.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="全链路监控" scheme="https://comlc.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%85%A8%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="APM" scheme="https://comlc.github.io/tags/APM/"/>
    
      <category term="全链路监控" scheme="https://comlc.github.io/tags/%E5%85%A8%E9%93%BE%E8%B7%AF%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Docker使用</title>
    <link href="https://comlc.github.io/2019/08/20/Docker%E4%BD%BF%E7%94%A8/"/>
    <id>https://comlc.github.io/2019/08/20/Docker使用/</id>
    <published>2019-08-20T02:00:00.000Z</published>
    <updated>2020-03-21T11:22:02.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>docker是一个开源的应用容器引擎。Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。</p><a id="more"></a><h2 id="容器VS虚拟机"><a href="#容器VS虚拟机" class="headerlink" title="容器VS虚拟机"></a>容器VS虚拟机</h2><blockquote><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。  </p></blockquote><p><img src="/2019/08/20/Docker使用/../../../../img/docker/img1.png" alt="容器和虚拟机对比图"></p><blockquote><p>容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。虚拟机(VM)是一个物理硬件层抽象，用于将一台服务器变成多台服务器。  </p></blockquote><p><img src="/2019/08/20/Docker使用/../../../../img/docker/img2.png" alt="容器和虚拟机对比图"></p><h2 id="Docker基本概念"><a href="#Docker基本概念" class="headerlink" title="Docker基本概念"></a>Docker基本概念</h2><ol><li>镜像（Image）就是一个只读模板，类似于Java中的类。</li><li>容器（Container）是从镜像创建的运行实例，它可以被启动，开始、停止、删除、每个容器都是互相隔离的，类似于Java中创建的对象。</li><li>仓库（Repository）分公共仓库和私有仓库，最大的公开仓库是docker Hub。<br><img src="/2019/08/20/Docker使用/../../../../img/docker/img3.png" alt="Docker运行流程"></li></ol><h2 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h2><ol><li>整体是C/S架构，docker daemon就是docker的守护进程即server端，可以是远程的，也可以是本地的，客户端Docker client是通过rest api进行通信。</li><li>docker cli用来管理容器和镜像，客户端提供一个只读镜像，然后通过镜像可以创建多个容器。<br><img src="/2019/08/20/Docker使用/../../../../img/docker/img4.png" alt="Docker结构引擎"></li></ol><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><ol><li>更新apt包：<code>sudo apt-get update</code>。</li><li>安装以下包以使apt可以通过HTTPS使用存储库（repository）：<code>apt-get install apt-transport-https ca-certificates curl software-properties-common</code>。</li><li>添加Docker官方的GPG密钥：<code>curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</code>。</li><li>使用下面的命令来设置stable存储库：<code>sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot;</code>。</li><li>安装最新版本的Docker CE：<code>sudo apt-get install -y docker-ce</code>。</li><li>查看docker服务是否启动：<code>systemctl status docker</code>，若未启动，执行<code>sudo systemctl start docker</code>。</li><li>设置开机自启动：<code>systemctl enable docker.service</code>。</li></ol><h2 id="Docker命令整理"><a href="#Docker命令整理" class="headerlink" title="Docker命令整理"></a>Docker命令整理</h2><ol><li><p>容器操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">docker create # 创建一个容器但是不启动它</span><br><span class="line">docker run # 创建并启动一个容器</span><br><span class="line">docker stop # 停止容器运行，发送信号SIGTERM</span><br><span class="line">docker start # 启动一个停止状态的容器</span><br><span class="line">docker restart # 重启一个容器</span><br><span class="line">docker rm # 删除一个容器</span><br><span class="line">docker kill # 发送信号给容器，默认SIGKILL</span><br><span class="line">docker attach # 连接(进入)到一个正在运行的容器</span><br><span class="line">docker wait # 阻塞一个容器，直到容器停止运行</span><br><span class="line"></span><br><span class="line">docker ps # 显示状态为运行（Up）的容器</span><br><span class="line">docker ps -a # 显示所有容器,包括运行中（Up）的和退出的(Exited)</span><br><span class="line">docker inspect # 深入容器内部获取容器所有信息</span><br><span class="line">docker logs # 查看容器的日志(stdout/stderr)</span><br><span class="line">docker events # 得到docker服务器的实时的事件</span><br><span class="line">docker port # 显示容器的端口映射</span><br><span class="line">docker top # 显示容器的进程信息</span><br><span class="line">docker diff # 显示容器文件系统的前后变化</span><br><span class="line"></span><br><span class="line">docker cp # 从容器里向外拷贝文件或目录</span><br><span class="line">docker export # 将容器整个文件系统导出为一个tar包，不带layers、tag等信息</span><br><span class="line"></span><br><span class="line">docker exec -it [container] /bin/bash #在容器里执行一个命令，可以执行bash进入交互式</span><br></pre></td></tr></table></figure></li><li><p>镜像操作：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker images # 显示本地所有的镜像列表</span><br><span class="line">docker import # 从一个tar包创建一个镜像，往往和export结合使用</span><br><span class="line">docker build # 使用Dockerfile创建镜像（推荐）</span><br><span class="line">docker commit # 从容器创建镜像</span><br><span class="line">docker rmi # 删除一个镜像</span><br><span class="line">docker load # 从一个tar包创建一个镜像，和save配合使用</span><br><span class="line">docker save # 将一个镜像保存为一个tar包，带layers和tag信息</span><br><span class="line">docker history # 显示生成一个镜像的历史命令</span><br><span class="line">docker tag # 为镜像起一个别名</span><br><span class="line"></span><br><span class="line">docker login # 登录到一个registry</span><br><span class="line">docker search # 从registry仓库搜索镜像</span><br><span class="line">docker pull # 从仓库下载镜像到本地</span><br><span class="line">docker push # 将一个镜像push到registry仓库中</span><br></pre></td></tr></table></figure></li></ol><h2 id="Docker私服搭建"><a href="#Docker私服搭建" class="headerlink" title="Docker私服搭建"></a>Docker私服搭建</h2><ol><li>拉取registry仓库docker镜像：<code>docker pull registry</code>。</li><li>挂载相关的配置：<code>mkdir -p /opt/docker-registry/auth</code>。</li><li>生成账号密码comlc/comlc：<code>docker run --entrypoint htpasswd registry -Bbn comlc comlc  &gt;&gt; /docker/registry/auth/htpasswd</code>。</li><li><p>设置配置文件：执行<code>mkdir -p /opt/docker-registry/config</code>，新建文件<code>vim /opt/docker-registry/config/config.yml</code>，输入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line">log:</span><br><span class="line">  fields:</span><br><span class="line">    service: registry</span><br><span class="line">storage:</span><br><span class="line">  delete:</span><br><span class="line">    enabled: true</span><br><span class="line">  cache:</span><br><span class="line">    blobdescriptor: inmemory</span><br><span class="line">  filesystem:</span><br><span class="line">    rootdirectory: /var/lib/registry</span><br><span class="line">http:</span><br><span class="line">  addr: :5000</span><br><span class="line">  headers:</span><br><span class="line">    X-Content-Type-Options: [nosniff]</span><br><span class="line">health:</span><br><span class="line">  storagedriver:</span><br><span class="line">    enabled: true</span><br><span class="line">    interval: 10s</span><br><span class="line">threshold: 3</span><br></pre></td></tr></table></figure></li><li><p>创建registry docker进程，执行命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always  --name=registry \</span><br><span class="line">-v /opt/docker-registry/:/var/lib/registry/ \</span><br><span class="line">-v /opt/docker-registry/auth/:/auth/ \</span><br><span class="line">-e "REGISTRY_AUTH=htpasswd" \</span><br><span class="line">-e "REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm" \</span><br><span class="line">-e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \</span><br><span class="line">registry</span><br></pre></td></tr></table></figure></li><li><p>验证私服：浏览器<code>http://192.168.2.102:5000/v2/_catalog</code>会要求输入用户名密码。</p></li></ol><h2 id="Docker开启远程连接"><a href="#Docker开启远程连接" class="headerlink" title="Docker开启远程连接"></a>Docker开启远程连接</h2><ol><li>开启宿主机的2375端口：修改文件<code>vim /lib/systemd/system/docker.service</code>，将原内容<code>ExecStart=/usr/bin/dockerd -H fd://</code>替换成<code>ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock -H tcp://0.0.0.0:7654</code>。</li><li>将port(2375)写入<code>/etc/profile</code>配置，执行<code>export DOCKER_HOST=tcp://0.0.0.0:2375</code>，使配置生效，执行<code>source /etc/profile</code>。</li><li>重启docker守护进程：<code>systemctl daemon-reload</code>。</li><li>重启Docker服务：<code>systemctl restart docker.service</code>。</li><li>验证docker服务是否有问题：<code>docker version</code>，查看端口监听情况：<code>netstat -lntp | grep dockerd</code>。<br><strong><em>Docker私服和远程连接都开启后，即可通过如dockerfile-maven-plugin插件进行远程构建镜像并推到私服</em></strong></li></ol><h2 id="Dockerfile语法"><a href="#Dockerfile语法" class="headerlink" title="Dockerfile语法"></a>Dockerfile语法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">FROM openjdk:8u181-jdk-stretch                  #指定基础镜像，必须为第一个命令</span><br><span class="line"></span><br><span class="line">ENV JAVA_OPTS=" -Xms256M "                      #设置环境变量，后续可以被RUN指令使用，容器运行起来之后，也可以在容器中获取这些环境变量</span><br><span class="line"></span><br><span class="line">ARG OAP_CONFIG                                  #定义一个变量，在docker build创建镜像的时候，使用--build-arg=来指定参数，在dockerfile-maven-plugin插件通过buildArgs来指定</span><br><span class="line">ARG OAP_LIBS</span><br><span class="line"></span><br><span class="line">WORKDIR skywalking                              #指定配置工作目录，可以使用多个WORKDIR指令，若后续指令用得是相对路径，则会基于之前的命令指定路径</span><br><span class="line"></span><br><span class="line">COPY $&#123;OAP_CONFIG&#125; config/                      #复制本地主机src目录或文件到容器的desc目录</span><br><span class="line">COPY $&#123;OAP_LIBS&#125; oap-libs/</span><br><span class="line">COPY docker-entrypoint.sh .</span><br><span class="line"></span><br><span class="line">RUN mkdir ext-config; \                         #构建镜像时执行的命令，包括shell执行和exec执行</span><br><span class="line">    mkdir ext-libs;</span><br><span class="line"></span><br><span class="line">EXPOSE 12800 11800                              #声明外界交互的端口</span><br><span class="line"></span><br><span class="line">ENTRYPOINT ["bash", "docker-entrypoint.sh"]     #配置容器，使其可执行化。配合CMD可省去"application"，只使用参数</span><br></pre></td></tr></table></figure><h2 id="常用Docker镜像安装"><a href="#常用Docker镜像安装" class="headerlink" title="常用Docker镜像安装"></a>常用Docker镜像安装</h2><ol><li><p>Mysql镜像安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1、docker pull mysql:8.0.16</span><br><span class="line">2、mkdir -p /opt/docker-mysql/conf.d</span><br><span class="line">增加并修改配置文件config-file.cnf如下</span><br><span class="line">[mysqld]</span><br><span class="line">lower_case_table_names=1 </span><br><span class="line"><span class="meta">#</span>server-id=1</span><br><span class="line">datadir=/opt/docker-mysql/data</span><br><span class="line">character-set-server=utf8</span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line">expire_logs_days=7</span><br><span class="line"><span class="meta">#</span>socket=/var/lib/mysql/mysqlx.sock</span><br><span class="line"><span class="meta">#</span>symbolic-links=0</span><br><span class="line"><span class="meta">#</span>sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES </span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=/var/log/mysqld.log</span><br><span class="line">pid-file=/var/run/mysqld/mysqld.pid</span><br><span class="line">3、增加数据文件夹mkdir -p /opt/docker-mysql/var/lib/mysql</span><br><span class="line">4、启动mysql</span><br><span class="line">docker run --name mysql --restart=always -p 3306:3306 \</span><br><span class="line">-v /opt/docker-mysql/conf.d:/etc/mysql/conf.d \</span><br><span class="line">-v /opt/docker-mysql/var/lib/mysql:/var/lib/mysql </span><br><span class="line">-e MYSQL_ROOT_PASSWORD=comlc -d mysql:8.0.16</span><br><span class="line">5、常用命令</span><br><span class="line">进入容器docker exec -it mysql bash</span><br><span class="line">mysql登录mysql -u root -p或mysql -u root -p -h 192.168.2.102</span><br><span class="line">查看日志docker logs -f mysql</span><br><span class="line">备份数据docker exec mysql sh -c 'exec mysqldump --all-databases -uroot -p"comlc"' &gt; /some/path/on/your/host/all-databases.sql</span><br><span class="line">恢复数据docker exec -i mysql sh -c 'exec mysql -uroot -p"comlc"' &lt; /some/path/on/your/host/all-databases.sql</span><br><span class="line">重启容器docker restart mysql</span><br></pre></td></tr></table></figure></li><li><p>Redis镜像安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、docker pull redis:latest</span><br><span class="line">2、mkdir -p /opt/docker-redis/conf</span><br><span class="line">mkdir -p /opt/docker-redis/data</span><br><span class="line">3、获取redis的默认配置模版</span><br><span class="line">wget https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf -O /opt/docker-redis/conf/redis.conf</span><br><span class="line">4、vim /opt/docker-redis/conf/redis.conf修改配置为</span><br><span class="line">bind 127.0.0.1 #注释掉这部分，这是限制redis只能本地访问</span><br><span class="line">protected-mode no #默认yes，开启保护模式，限制为本地访问</span><br><span class="line">daemonize no#默认no，改为yes意为以守护进程方式启动，可后台运行，除非kill进程，改为yes会使配置文件方#式启动redis失败</span><br><span class="line">appendonly yes #redis持久化（可选）</span><br><span class="line">requirepass comlc #个人测试使用的密码</span><br><span class="line">5、docker run --restart=always -p 6379:6379 --name redis \</span><br><span class="line">-v /opt/docker-redis/conf/redis.conf:/etc/redis/redis.conf \</span><br><span class="line">-v /opt/docker-redis/data:/data \</span><br><span class="line">-d redis redis-server /etc/redis/redis.conf --appendonly yes</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;docker是一个开源的应用容器引擎。Docker可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务" scheme="https://comlc.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="部署环境" scheme="https://comlc.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="Docker" scheme="https://comlc.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Tesseract-OCR4源码编译与使用</title>
    <link href="https://comlc.github.io/2018/11/24/Tesseract-OCR4%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://comlc.github.io/2018/11/24/Tesseract-OCR4源码编译与使用/</id>
    <published>2018-11-24T08:00:00.000Z</published>
    <updated>2019-04-04T10:42:41.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Tesseract是开源的OCR识别引擎，最初由惠普实验室支持，1996年被移植到Windows上，1998年进行了C++化。在2005年Tesseract由惠普公司宣布开源。2006年到现在，都由Google公司开发。目前，Tesseract可以识别超过100种语言，也可以用来训练其它的语言。新版本中增加了一个基于LSTM神经网络的新OCR引擎。</p></blockquote><a id="more"></a><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><ol><li>下载<a href="https://github.com/DanBloomberg/leptonica/releases" target="_blank" rel="noopener">leptonica-1.78.0.tar.gz</a>源码</li><li>下载<a href="https://github.com/tesseract-ocr/tesseract/releases" target="_blank" rel="noopener">opencv_contrib-4.0.1.zip</a>源码，Tesseract版本和Leptonica的最低版本要求：  </li></ol><table><thead><tr><th style="text-align:center">Tesseract</th><th style="text-align:center">Leptonica</th><th style="text-align:center">Ubuntu</th></tr></thead><tbody><tr><td style="text-align:center">4.00</td><td style="text-align:center">1.74.2</td><td style="text-align:center">Ubuntu 18.04</td></tr><tr><td style="text-align:center">3.05</td><td style="text-align:center">1.74.0</td><td style="text-align:center">必须从源码构建</td></tr><tr><td style="text-align:center">3.04</td><td style="text-align:center">1.71</td><td style="text-align:center">Ubuntu 16.04</td></tr><tr><td style="text-align:center">3.03</td><td style="text-align:center">1.70</td><td style="text-align:center">Ubuntu 14.04</td></tr><tr><td style="text-align:center">3.02</td><td style="text-align:center">1.69</td><td style="text-align:center">Ubuntu 12.04</td></tr></tbody></table><ol><li>在<code>D:\BeawanDevelop\VSworkspace\tesseract-ocr</code>下创建<code>install</code>、<code>build-win</code>、<code>build-linux</code>。</li></ol><h2 id="CMake-VS2017编译"><a href="#CMake-VS2017编译" class="headerlink" title="CMake+VS2017编译"></a>CMake+VS2017编译</h2><blockquote><p>CPPAN(C ++ Archive Network)是建立在CMake之上具有构建系统功能的跨平台C / C ++依赖管理器。 它支持快速的脚本式编码和原型制作以及处理大型项目。 可以很方便的查找、共享和重用库以及发布您的项目。你只需要将时间花在代码上，而不需要管理依赖关系。 CPPAN帮您将包装时间降低至几秒钟！它支持简单的交叉编译，继承并且把你自己的设置、标志推送到每个依赖。CPPAN之于C++就像Maven之于Java。CPPAN可以理解为C++的包管理器，包含了众多依赖包，只需要向CPPAN指定依赖包，CPPAN就会帮你下载好需要的依赖包和相关配置。</p></blockquote><ol><li>下载<a href="https://cppan.org/client/" target="_blank" rel="noopener">cppan-master-Windows-client.zip</a>，解压到相应目录，并配置环境变量Path如<code>D:\ProgramFiles\cppan</code>。</li><li>将Tesseract的源码解压到<code>build-win</code>目录下。打开<code>CMD</code>切换至源码目录，执行<code>cppan</code>下载依赖包，等待时间可能有些长，如下图：<br><img src="/2018/11/24/Tesseract-OCR4源码编译与使用/../../../../img/tesseract/cppan.png" alt="cppan下载依赖包"></li><li>待下载完后，在Tesseract源码目录下新建<code>build</code>并切换至该目录。执行<code>cmake ../ -G &quot;Visual Studio 15 2017 Win64&quot; -DSTATIC=1</code>生成VS2017项目。</li><li>以管理员身份打开VS2017，并打开刚刚生成的项目，依次点击<code>生成-&gt;生成解决方案</code>。这里会报错，基本是因为编码问题，将报错的文件编码改成<code>UTF-8带签名</code>即可，如下图：<br><img src="/2018/11/24/Tesseract-OCR4源码编译与使用/../../../../img/tesseract/error.png" alt="报错"></li><li>生成完后右击<code>CMake Targets-&gt;INSTALL</code>生成(如果不以管理员身份打开，这里会因为权限问题报错<code>&lt;Exec Command=&quot;%(PostBuildEvent.Command)$(_BuildSuffix)&quot; Condition=&quot;&#39;%(PostBuildEvent.Command)&#39; != &#39;&#39;&quot;/&gt;</code>)，生成完会在<code>C:\Program Files</code>下看到<code>tesseract</code>安装目录，可以看到里面包含了头文件和静态库文件。</li><li>若自己项目中运行库是多线程(/MTd或/MT)，则Tesseract库也需要是多线程(/MTd或/MT)的，需单独将子项目<code>libtesseract</code>设置成多线程(/MTd或/MT)，并右击单独编译生成<code>tesseract40.lib</code>库。</li><li>关于Leptonica头文件可以从源码中提取或在<code>C:\Users\comlc\.cppan\storage\src</code>目录下找。编译的依赖库文件都在<code>C:\Users\comlc\.cppan\storage\lib</code>目录下。</li><li>VS2017新建Windows控制台应用程序项目，配置头文件的附加包含目录、静态库的附加库目录、附加依赖项，进行测试。若报错<code>无法解析外部符号closesocket</code>如<a href="https://github.com/Microsoft/vcpkg/issues/2435" target="_blank" rel="noopener">https://github.com/Microsoft/vcpkg/issues/2435</a>，需引入<code>ws2_32.lib</code>库，若报错<code>无法解析的外部符号 __imp__fopen</code>等，需引入<code>msvcrtd.lib</code>库</li><li>也可以直接用CPPAN进行编译<a href="https://github.com/cppan/cppan/issues/19" target="_blank" rel="noopener">https://github.com/cppan/cppan/issues/19</a>，更多编译方法可见<a href="https://github.com/tesseract-ocr/tesseract/wiki/Compiling" target="_blank" rel="noopener">https://github.com/tesseract-ocr/tesseract/wiki/Compiling</a></li></ol><h2 id="Linux编译"><a href="#Linux编译" class="headerlink" title="Linux编译"></a>Linux编译</h2><blockquote><p>Tesseract在linux下编译需要用到autotools工具集(包含autoscan、autoconf、automake等)来生成makefile文件，然后在进行编译安装。</p></blockquote><ol><li>将Leptonica和Tesseract的源码都解压到<code>build-linux</code>目录下。</li><li>这里我使用的是Win10子系统Ubuntu，先安装依赖库，执行<code>sudo apt-get install autoconf automake libtool pkg-config libpng-dev libjpeg8-dev libtiff5-dev zlib1g-dev</code>。<br>如果需要安装训练工具还需安装<code>apt-get install libicu-dev libpango1.0-dev libcairo2-dev</code>。</li><li>首先安装Leptonica库，可以选择通过<code>apt-get install libleptonica-dev</code>安装发行版本，我这里选择用源码编译。</li><li>进入leptonica源码目录，执行<code>./autogen.sh</code>生成configure，然后执行<code>./configure  --enable-shared=no --enable-static=yes</code>，如下图：<br><img src="/2018/11/24/Tesseract-OCR4源码编译与使用/../../../../img/tesseract/leptonica-autogen.png" alt="Leptonica编译一"><br><img src="/2018/11/24/Tesseract-OCR4源码编译与使用/../../../../img/tesseract/leptonica-configure.png" alt="Leptonica编译二"></li><li>依次执行<code>make</code>和<code>make install</code>进行编译和安装，安装完后可在<code>/usr/local/include</code>目录下看到leptonica库的头文件，<code>/usr/local/lib</code>目录下有<code>liblept.a</code>静态库文件，如下图：<br><img src="/2018/11/24/Tesseract-OCR4源码编译与使用/../../../../img/tesseract/leptonica-make.png" alt="Leptonica编译三"><br><img src="/2018/11/24/Tesseract-OCR4源码编译与使用/../../../../img/tesseract/leptonica-install.png" alt="Leptonica编译四"></li><li>接下来编译tesseract库，切换至tesseract源码目录，执行<code>./autogen.sh</code>生成configure，然后执行<code>./configure  --enable-shared=no --enable-static=yes</code>，在<a href="https://github.com/tesseract-ocr/tesseract/issues/961" target="_blank" rel="noopener">github issues</a>里有人讨论禁用OpenMP是否可以改善性能，若想禁用需加上<code>--disable-openmp</code>，可以看到tesseract能找到刚刚编译的leptonica库，如下图：<br><img src="/2018/11/24/Tesseract-OCR4源码编译与使用/../../../../img/tesseract/OpenMP-Support.png" alt="OpenMP支持"><br><img src="/2018/11/24/Tesseract-OCR4源码编译与使用/../../../../img/tesseract/check-leptonica.png" alt="Leptonica模块检查"><br><img src="/2018/11/24/Tesseract-OCR4源码编译与使用/../../../../img/tesseract/tesseract-configure.png" alt="Tesseract编译"></li><li>依次执行<code>make -j4</code>和<code>make install</code>进行编译和安装，由于我的机器是4核8线程，所以这里使用<code>-j4</code>来加快编译速度。安装完后可在<code>/usr/local/include</code>目录下看到tesseract库的头文件，<code>/usr/local/lib</code>目录下有<code>libtesseract.a</code>静态库文件。</li><li>执行<code>tesseract --version</code>可以查看版本信息。</li><li>用VS2017创建CMake项目进行测试，测试代码可参考<a href="https://github.com/tesseract-ocr/tesseract/wiki/APIExample" target="_blank" rel="noopener">API Examples</a>，配置<code>CMakeLists.txt</code>时，链接库Tesseract和Leptonica的顺序要注意，CMake中链接库的顺序是A依赖B，那么B放在A的后面。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">find_package (PkgConfig REQUIRED)</span><br><span class="line">pkg_search_module (LEPTONICA REQUIRED lept)</span><br><span class="line">pkg_search_module (TESSERACT REQUIRED tesseract)</span><br><span class="line">target_link_libraries (OCRTest $&#123;TESSERACT_LIBRARIES&#125; $&#123;LEPTONICA_LIBRARIES&#125;)</span><br></pre></td></tr></table></figure></li></ol><h2 id="C-编码问题"><a href="#C-编码问题" class="headerlink" title="C++编码问题"></a>C++编码问题</h2><blockquote><p>在测试Tesseract-OCR的时候，由于VS的源文件编码不是UTF-8的，所以在输出<code>GetUTF8Text</code>和设置<code>tessedit_char_whitelist</code>的时候出现乱码，因此查阅了关于编码相关知识。</p></blockquote><table><thead><tr><th>因素</th><th>Windows</th><th>Linux</th></tr></thead><tbody><tr><td>源代码文件字符集</td><td>可通过高级保存选项设置</td><td>默认UTF-8</td></tr><tr><td>编译器读取源代码时的字符集</td><td>源文件有没有BOM，若有则认为你的源码字符集与源文件一致，若没有则认为你的源码字符集是Locale的</td><td>与源文件一致</td></tr><tr><td>编译器在编译时的字符集</td><td>MSVC编译器默认的编码是根据系统Locale来决定的，可在CMD中输入<code>chcp</code>命令，若活动代码页为936，对应的编码为GBK</td><td>默认UTF-8</td></tr><tr><td>运行可执行程序的控制台窗口所使用的字符集</td><td>默认根据系统Locale决定</td><td>默认根据系统Locale决定</td></tr></tbody></table><ol><li>我理解的字符集就是将抽象字符和字节相互转化的一系列规则，转码即是将抽象字符以A字符集规则转换成A字符集的字节流，再将A字符集的字节流转换成B字符集的字节流，最后将B字符集的字节流以B字符集规则解析成抽象字符。</li><li>源代码文件字符集决定了抽象字符(指人能识别的文字)保存到硬盘中是什么样的字节，例如C1字符集则按该字符集规则映射并存储为C1字符集的字节。</li><li>编译器在编译前读取源文件时，将源文件中的抽象字符视为C2字符集，若C1和C2不同，则需要由C1字符集的字节流转换为C2字符集的字节流。</li><li>编译器在编译时会将根据编译器程序内码C3，将C2转成C3保存在目标文件中，gcc程序内码默认为程序内码都是UTF-8，但似乎并不会对源文件中的字符编码进行转换，而是直接把字符串原样存放到目标文件中。</li><li>在执行目标文件时，C++标准库会识别运行环境的编码C4，并根据C4编码，将存储在目标文件的的字节解析成抽象字符。</li><li>在VS环境中，只要编译器正确识别源文件字符编码，则生成的目标文件默认都为GBK的，无法正确识别如源文件编码为UTF-8无BOM，则编译器会视为Locale默认的GBK编码，最终会出现乱码。</li><li>在gcc环境中，编译器编译的目标文件编码会与源文件一致。默认情况下，若源文件为GB2312，则目标文件的字符存储为GB2312，而Linux终端编码默认UTF-8，通过解析最终输出打印会出现乱码。</li><li>字符不管是作为输出打印到终端，还是作为输入传进第三方库，都以目标文件中字符的编码为准。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Tesseract是开源的OCR识别引擎，最初由惠普实验室支持，1996年被移植到Windows上，1998年进行了C++化。在2005年Tesseract由惠普公司宣布开源。2006年到现在，都由Google公司开发。目前，Tesseract可以识别超过100种语言，也可以用来训练其它的语言。新版本中增加了一个基于LSTM神经网络的新OCR引擎。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其他" scheme="https://comlc.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
      <category term="开发环境" scheme="https://comlc.github.io/categories/%E5%85%B6%E4%BB%96/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="Tesseract" scheme="https://comlc.github.io/tags/Tesseract/"/>
    
      <category term="OCR" scheme="https://comlc.github.io/tags/OCR/"/>
    
  </entry>
  
  <entry>
    <title>OpenCV4源码编译与使用</title>
    <link href="https://comlc.github.io/2018/11/23/OpenCV4%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://comlc.github.io/2018/11/23/OpenCV4源码编译与使用/</id>
    <published>2018-11-23T07:00:00.000Z</published>
    <updated>2019-04-04T09:54:07.097Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。</p></blockquote><a id="more"></a><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><table><thead><tr><th style="text-align:center">模块</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">Core</td><td>核心功能模块，包括基本数据结构、基本绘图功能、辅助功能和系统函数、与OpenGL的互操作等</td></tr><tr><td style="text-align:center">Imgproc</td><td>图像处理模块，包括线性和非线性的图像滤波、图像的几何变换、图像转换、直方图相关、结构分析和形状描述、运动分析和对象跟踪、特征检测、目标检测等</td></tr><tr><td style="text-align:center">Highgui</td><td>高级图形用户界面，可以用来显示图像或者简单的输入的用户交互函数，这可以看作是一个非常轻量级的Windows UI工具包。</td></tr><tr><td style="text-align:center">Features2D</td><td>2D功能模块，包括特征检测和描述、特征匹配、关键点绘制、匹配功能绘制等</td></tr><tr><td style="text-align:center">ML</td><td>机器学习模块，主要是统计模型和分类算法，包括决策树、支持向量机、神经网络等</td></tr><tr><td style="text-align:center">Flann</td><td>高维的近似近邻快速搜索算法库，包括快速近似最近邻搜索、聚类</td></tr><tr><td style="text-align:center">Objdectect</td><td>目标检测模块，使用Cascade Classification（级联分类）和Latent SVM进行检测特定目标，比如人脸或者行人的算法，也可以训练检测器并用来检测其他物体。</td></tr><tr><td style="text-align:center">Contrib</td><td>在 OpenCV3.0后，融合进了opencv_contrib</td></tr><tr><td style="text-align:center">Calib3d</td><td>主要是相机校准和三维重建相关的内容，包括包括校准单个、双目以及多个相机的算法实现</td></tr><tr><td style="text-align:center">Photo</td><td>包括图像修复、图像去噪</td></tr><tr><td style="text-align:center">Video</td><td>视频分析模块，包括运动估计、背景分离、对象跟踪等视频处理相关内容</td></tr><tr><td style="text-align:center">Stitching</td><td>图像拼接模块，包括特点寻找和匹配图像、图片歪斜、曝光补偿、图片混合、自动校准等</td></tr><tr><td style="text-align:center">Shape</td><td>形状的匹配以及距离计算</td></tr><tr><td style="text-align:center">GPU</td><td>运用GPU加速的计算机视觉模块</td></tr><tr><td style="text-align:center">Ocl</td><td>运用OpenCL加速的计算机视觉组件模块</td></tr><tr><td style="text-align:center">Nonfree</td><td>包含一些受到专利保护的或者受到使用限制的（比如SIFT算法）算法</td></tr></tbody></table><h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><ol><li>下载<a href="https://opencv.org/releases.html" target="_blank" rel="noopener">opencv-4.0.1.zip</a>源码</li><li>下载<a href="https://github.com/opencv/opencv_contrib/releases" target="_blank" rel="noopener">opencv_contrib-4.0.1.zip</a>源码，注意版本要一致。</li><li>在<code>D:\BeawanDevelop\VSworkspace\OpenCV</code>下创建<code>source</code>、<code>build-win</code>、<code>build-linux</code>，将opencv和opencv_contrib的源码解压放到<code>source</code>目录下。</li></ol><h2 id="CMake-VS2017编译"><a href="#CMake-VS2017编译" class="headerlink" title="CMake+VS2017编译"></a>CMake+VS2017编译</h2><ol><li>利用CMake生成VS2017项目，打开CMake选择源码所在路径和编译输出的路径，然后点击<code>Configure</code>选择<code>Visual Studio 15 2017 Win64</code>生成器，如下图：<br><img src="/2018/11/23/OpenCV4源码编译与使用/../../../../img/opencv/win-cmake1.png" alt="CMake编译步骤一"></li><li>由于我要生成静态库，所以需取消<code>BUILD_SHARED_LIBS</code>勾选，并且还要设置<code>OPENCV_EXTRA_MODULES_PATH</code>路径，以将opencv_contrib作为模块一起编译。这里还需要注意<code>OPENCV_ENABLE_NONFREE</code>设置，需将其勾选(这是由于SURF和SIFT属于收费模块，若后续想要使用却没有定义OPENCV_ENABLE_NONFREE，则会抛异常不能使用，反正可以编译正常使用)，最后再次点击<code>Configure</code>，如下图：<br><img src="/2018/11/23/OpenCV4源码编译与使用/../../../../img/opencv/win-cmake2.png" alt="CMake编译步骤二"></li><li>待编译完成后，点击<code>Generate</code>生成VS2017项目，再点击<code>Open Project</code>打开项目。</li><li>在VS2017中点击<code>生成-&gt;批生成</code>，选中<code>INSTALL</code>两项，然后开始生成，需等待一些时间，如下图：<br><img src="/2018/11/23/OpenCV4源码编译与使用/../../../../img/opencv/win-vs.png" alt="VS2017编译静态库"></li><li>待VS编译完后，会在工程目录下看到<code>install</code>目录，里面包括了调用OpenCV需要用到的include文件和静态库文件(有Debug和Release版本)</li><li>在VS2017上新建Windows控制台应用程序项目，配置头文件的附加包含目录、静态库的附加库目录、附加依赖项，编写程序测试OpenCV静态库。若想生成的可执行文件在没有OpenCV的环境下也可以运行，需要设置<code>配置属性-&gt;C/C++-&gt;代码生成</code>，将运行库改成<code>多线程调试(/MTD)</code>或<code>多线程(MT)</code>。</li></ol><h2 id="Linux编译"><a href="#Linux编译" class="headerlink" title="Linux编译"></a>Linux编译</h2><ol><li>这里我使用的是Win10子系统Ubuntu，先安装依赖库，执行<code>sudo apt-get install build-essential pkg-config ccache libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg.dev libtiff5.dev libswscale-dev libjasper-dev gtk+-3.0 libdc1394-22-dev libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev libavresample-dev</code>，安装依赖库前可以选择性的将软件源更新下，各依赖包若有新版本可以通过<code>apt-cache search</code>查看。</li><li>若碰到<code>libjasper-dev</code>库无法安装，可以依次执行<br><code>sudo add-apt-repository &quot;deb http://security.ubuntu.com/ubuntu xenial-security main&quot;</code><br><code>sudo apt update</code>更新软件源。</li><li>在Ubuntu上安装<code>xterm</code>并开启SSH服务，然后在用<code>Xstart</code>连接Ubuntu，执行<code>cmake-gui</code>可以打开CMake图形化界面。</li><li>同样需要配置源码路径以及编译输出路径，然后点击<code>Configure</code>选择<code>Unix Makefiles</code>生成器，如下图：<br><img src="/2018/11/23/OpenCV4源码编译与使用/../../../../img/opencv/linux-cmake1.png" alt="CMake编译步骤一"></li><li>取消勾选<code>BUILD_SHARED_LIBS</code>，设置<code>OPENCV_EXTRA_MODULES_PATH</code>路径，勾选<code>OPENCV_ENABLE_NONFREE</code>、<code>BUILD_JASPER</code>、<code>BUILD_JPEG</code>、<code>BUILD_PNG</code>、<code>BUILD_TIFF</code>、<code>BUILD_WEBP</code>、<code>BUILD_ZLIB</code>，再次点击<code>Configure</code>。</li><li>待编译完成后，点击<code>Generate</code>生成Makefile，将目录切换至<code>build-linux</code>下，执行<code>make</code>命令开始编译静态库，如下图：<br><img src="/2018/11/23/OpenCV4源码编译与使用/../../../../img/opencv/linux-make2.png" alt="make编译"></li><li>执行<code>make install</code>命令，会将OpenCV安装到<code>/usr/local</code>目录下，执行<code>opencv_version</code>命令可以看到版本为4.0.1。include头文件在<code>/usr/local/include/opencv4</code>目录下，静态库文件在<code>/usr/local/lib</code>目录下。<br><img src="/2018/11/23/OpenCV4源码编译与使用/../../../../img/opencv/linux-make3.png" alt="make install安装"></li><li><p>用VS2017创建CMake项目，并配置顶层CMakeLists.txt</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># CMakeList.txt: 顶层 CMake 项目文件，在此处执行全局配置</span><br><span class="line"># 并包含子项目。</span><br><span class="line">#</span><br><span class="line">cmake_minimum_required (VERSION <span class="number">3.8</span>)</span><br><span class="line"></span><br><span class="line">project (<span class="string">"OpenCVProject"</span>)</span><br><span class="line"></span><br><span class="line">IF (CMAKE_SYSTEM_NAME MATCHES <span class="string">"Linux"</span>)</span><br><span class="line">    MESSAGE(STATUS <span class="string">"Current Platform: Linux"</span>)</span><br><span class="line">    <span class="built_in">set</span>(SYSTEM_FLAG <span class="string">"linux64"</span>)</span><br><span class="line">    <span class="built_in">set</span>(OPENCV_INCLUDE_PATH <span class="string">"/usr/local/include/opencv4"</span>)</span><br><span class="line">    <span class="built_in">set</span>(OPENCV_LIB_PATH <span class="string">"/usr/local/lib"</span>)</span><br><span class="line">ELSEIF (CMAKE_SYSTEM_NAME MATCHES <span class="string">"Windows"</span>)</span><br><span class="line">    MESSAGE(STATUS <span class="string">"Current Platform: Windows"</span>)</span><br><span class="line">    <span class="built_in">set</span>(SYSTEM_FLAG <span class="string">"win64"</span>)</span><br><span class="line">    <span class="built_in">set</span>(OPENCV_INCLUDE_PATH <span class="string">"D:/BeawanDevelop/VSworkspace/OpenCV/build-contrib/install/include"</span>)</span><br><span class="line">    <span class="built_in">set</span>(OPENCV_LIB_PATH <span class="string">"D:/BeawanDevelop/VSworkspace/OpenCV/build-contrib/install/x64/vc15/staticlib"</span>)</span><br><span class="line">    <span class="built_in">set</span>(OPENCV_LIB_VERSION_SUFFIX <span class="string">"401"</span>)</span><br><span class="line">    IF (CMAKE_BUILD_TYPE MATCHES <span class="string">"Debug"</span>)</span><br><span class="line">        <span class="built_in">set</span>(OPENCV_LIB_BUILD_SUFFIX <span class="string">"d"</span>)</span><br><span class="line">    ELSE ()</span><br><span class="line">        <span class="built_in">set</span>(OPENCV_LIB_BUILD_SUFFIX <span class="string">""</span>)</span><br><span class="line">    ENDIF ()</span><br><span class="line">    <span class="built_in">set</span>(OPENCV_LIB_SUFFIX $&#123;OPENCV_LIB_VERSION_SUFFIX&#125;$&#123;OPENCV_LIB_BUILD_SUFFIX&#125;)</span><br><span class="line">ELSE ()</span><br><span class="line">    MESSAGE(STATUS <span class="string">"Other Platform: $&#123;CMAKE_SYSTEM_NAME&#125;"</span>)</span><br><span class="line">    <span class="built_in">set</span>(SYSTEM_FLAG <span class="string">"other"</span>)</span><br><span class="line">    <span class="built_in">set</span>(OPENCV_INCLUDE_PATH <span class="string">""</span>)</span><br><span class="line">    <span class="built_in">set</span>(OPENCV_LIB_PATH <span class="string">""</span>)</span><br><span class="line">ENDIF ()</span><br><span class="line"></span><br><span class="line">MESSAGE(STATUS $&#123;OPENCV_LIB_SUFFIX&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_DEBUG $&#123;PROJECT_SOURCE_DIR&#125;/../$&#123;SYSTEM_FLAG&#125;/Debug/lib)    </span><br><span class="line"><span class="built_in">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_RELEASE $&#123;PROJECT_SOURCE_DIR&#125;/../$&#123;SYSTEM_FLAG&#125;/Release/lib)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_DEBUG $&#123;CMAKE_BINARY_DIR&#125;/../$&#123;SYSTEM_FLAG&#125;/Debug/lib)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_RELEASE $&#123;CMAKE_BINARY_DIR&#125;/../$&#123;SYSTEM_FLAG&#125;/Release/lib)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG $&#123;PROJECT_SOURCE_DIR&#125;/../$&#123;SYSTEM_FLAG&#125;/Debug/bin)   </span><br><span class="line"><span class="built_in">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE $&#123;PROJECT_SOURCE_DIR&#125;/../$&#123;SYSTEM_FLAG&#125;/Release/bin)</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> (REPLACE <span class="string">"/MD"</span> <span class="string">"/MT"</span> CMAKE_CXX_FLAGS_DEBUG $&#123;CMAKE_CXX_FLAGS_DEBUG&#125;)</span><br><span class="line"><span class="built_in">string</span> (REPLACE <span class="string">"/MD"</span> <span class="string">"/MT"</span> CMAKE_CXX_FLAGS_RELEASE $&#123;CMAKE_CXX_FLAGS_RELEASE&#125;)</span><br><span class="line"></span><br><span class="line"># 包含子项目。</span><br><span class="line">add_subdirectory (<span class="string">"CreditRecognize"</span>)</span><br></pre></td></tr></table></figure></li><li><p>配置子目录的CMakeLists.txt，项目可在Windows和Linux上编译运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># CMakeList.txt: CreditRecognize 的 CMake 项目，在此处包括源代码并定义</span><br><span class="line"># 项目特定的逻辑。</span><br><span class="line">#</span><br><span class="line">cmake_minimum_required (VERSION <span class="number">3.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> (CREDIT_RECOGNIZE_VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">#添加头文件目录</span><br><span class="line">include_directories (</span><br><span class="line">    $&#123;OPENCV_INCLUDE_PATH&#125;</span><br><span class="line">    $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/include</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">#查找指定目录下的所有源文件，然后将结果存进指定变量名</span><br><span class="line">aux_source_directory($&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/src SOURCE_FILES)</span><br><span class="line"></span><br><span class="line">#添加需要链接的库文件目录，而LINK_LIBRARIES需要库文件路径</span><br><span class="line">IF (CMAKE_SYSTEM_NAME MATCHES <span class="string">"Linux"</span>)</span><br><span class="line">    find_package (OpenCV REQUIRED)</span><br><span class="line">ELSEIF (CMAKE_SYSTEM_NAME MATCHES <span class="string">"Windows"</span>)</span><br><span class="line">    link_directories ($&#123;OPENCV_LIB_PATH&#125;)</span><br><span class="line">ELSE ()</span><br><span class="line">ENDIF ()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#编译可执行程序，将源代码添加到此项目的可执行文件，也可以通过add_library编译动态库或静态库</span><br><span class="line">add_executable (CreditRecognize $&#123;SOURCE_FILES&#125;)</span><br><span class="line"></span><br><span class="line">IF (CMAKE_SYSTEM_NAME MATCHES <span class="string">"Linux"</span>)</span><br><span class="line">    target_link_libraries (CreditRecognize $&#123;OpenCV_LIBS&#125;)</span><br><span class="line">ELSEIF (CMAKE_SYSTEM_NAME MATCHES <span class="string">"Windows"</span>)</span><br><span class="line">    target_link_libraries (CreditRecognize IlmImf$&#123;OPENCV_LIB_BUILD_SUFFIX&#125; ippicvmt ippiw</span><br><span class="line">    ittnotify$&#123;OPENCV_LIB_BUILD_SUFFIX&#125; libjasper$&#123;OPENCV_LIB_BUILD_SUFFIX&#125; libjpeg-turbo$&#123;OPENCV_LIB_BUILD_SUFFIX&#125;</span><br><span class="line">    libpng$&#123;OPENCV_LIB_BUILD_SUFFIX&#125; libprotobuf$&#123;OPENCV_LIB_BUILD_SUFFIX&#125; libtiff$&#123;OPENCV_LIB_BUILD_SUFFIX&#125;</span><br><span class="line">    libwebp$&#123;OPENCV_LIB_BUILD_SUFFIX&#125; quirc$&#123;OPENCV_LIB_BUILD_SUFFIX&#125; zlib$&#123;OPENCV_LIB_BUILD_SUFFIX&#125;</span><br><span class="line">    opencv_aruco$&#123;OPENCV_LIB_SUFFIX&#125; opencv_bgsegm$&#123;OPENCV_LIB_SUFFIX&#125; opencv_bioinspired$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_calib3d$&#123;OPENCV_LIB_SUFFIX&#125; opencv_ccalib$&#123;OPENCV_LIB_SUFFIX&#125; opencv_core$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_datasets$&#123;OPENCV_LIB_SUFFIX&#125; opencv_dnn$&#123;OPENCV_LIB_SUFFIX&#125; opencv_dnn_objdetect$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_dpm$&#123;OPENCV_LIB_SUFFIX&#125; opencv_face$&#123;OPENCV_LIB_SUFFIX&#125; opencv_features2d$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_flann$&#123;OPENCV_LIB_SUFFIX&#125; opencv_fuzzy$&#123;OPENCV_LIB_SUFFIX&#125; opencv_gapi$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_hfs$&#123;OPENCV_LIB_SUFFIX&#125; opencv_highgui$&#123;OPENCV_LIB_SUFFIX&#125; opencv_img_hash$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_imgcodecs$&#123;OPENCV_LIB_SUFFIX&#125; opencv_imgproc$&#123;OPENCV_LIB_SUFFIX&#125; opencv_line_descriptor$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_ml$&#123;OPENCV_LIB_SUFFIX&#125; opencv_objdetect$&#123;OPENCV_LIB_SUFFIX&#125; opencv_optflow$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_phase_unwrapping$&#123;OPENCV_LIB_SUFFIX&#125; opencv_photo$&#123;OPENCV_LIB_SUFFIX&#125; opencv_plot$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_reg$&#123;OPENCV_LIB_SUFFIX&#125; opencv_rgbd$&#123;OPENCV_LIB_SUFFIX&#125; opencv_saliency$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_shape$&#123;OPENCV_LIB_SUFFIX&#125; opencv_stereo$&#123;OPENCV_LIB_SUFFIX&#125; opencv_stitching$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_structured_light$&#123;OPENCV_LIB_SUFFIX&#125; opencv_superres$&#123;OPENCV_LIB_SUFFIX&#125; opencv_surface_matching$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_text$&#123;OPENCV_LIB_SUFFIX&#125; opencv_tracking$&#123;OPENCV_LIB_SUFFIX&#125; opencv_video$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_videoio$&#123;OPENCV_LIB_SUFFIX&#125; opencv_videostab$&#123;OPENCV_LIB_SUFFIX&#125; opencv_xfeatures2d$&#123;OPENCV_LIB_SUFFIX&#125;</span><br><span class="line">    opencv_ximgproc$&#123;OPENCV_LIB_SUFFIX&#125; opencv_xobjdetect$&#123;OPENCV_LIB_SUFFIX&#125; opencv_xphoto$&#123;OPENCV_LIB_SUFFIX&#125;)</span><br><span class="line">ELSE ()</span><br><span class="line">ENDIF ()</span><br><span class="line"></span><br><span class="line"># TODO: 如有需要，请添加测试并安装目标。</span><br></pre></td></tr></table></figure></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;OpenCV是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows、Android和Mac操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="其他" scheme="https://comlc.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
      <category term="开发环境" scheme="https://comlc.github.io/categories/%E5%85%B6%E4%BB%96/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="OpenCV" scheme="https://comlc.github.io/tags/OpenCV/"/>
    
  </entry>
  
  <entry>
    <title>VS2017开发跨平台C++项目</title>
    <link href="https://comlc.github.io/2018/11/20/VS2017%E5%BC%80%E5%8F%91%E8%B7%A8%E5%B9%B3%E5%8F%B0C++%E9%A1%B9%E7%9B%AE/"/>
    <id>https://comlc.github.io/2018/11/20/VS2017开发跨平台C++项目/</id>
    <published>2018-11-20T03:00:00.000Z</published>
    <updated>2019-03-31T14:20:48.460Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>最近有项目需要进行特定场景下的OCR，因此需要编译最新的OpenCV+Tesseract源码，涉及到Windows和Linux平台，对于Windows有VS IDE，可对于Linux一直没用过makefile，也没用过其他IDE，于是乎转向CMake。</p><a id="more"></a><h2 id="CMake简介"><a href="#CMake简介" class="headerlink" title="CMake简介"></a>CMake简介</h2><blockquote><p>CMake是一个跨平台的编译工具，语法相对makefile要简单。它可以输出各种各样的makefile或者project。例如在Windows上可以编译并输出VS工程项目，在Linux/Unix上可以编译并输出makefile项目，在Mac上可以编译并输出xcode项目。</p></blockquote><h2 id="CMake安装"><a href="#CMake安装" class="headerlink" title="CMake安装"></a>CMake安装</h2><ol><li>Windows环境，下载<a href="https://cmake.org/download/" target="_blank" rel="noopener">Windows win64-x64</a>并安装。</li><li>Linux环境，下载<a href="https://cmake.org/download/" target="_blank" rel="noopener">Linux x86_64</a>，将<code>cmake-3.14.0-Linux-x86_64.tar.gz</code>拷贝到<code>/usr/local/</code>下，并解压<code>tar -zxvf cmake-3.14.0-Linux-x86_64.tar.gz</code></li><li>执行<code>ln -sf /usr/local/cmake-3.14.0-Linux-x86_64/bin/*  /usr/bin/</code></li><li>执行<code>cmake --version</code>查看版本信息。</li></ol><h2 id="CMake初探"><a href="#CMake初探" class="headerlink" title="CMake初探"></a>CMake初探</h2><ol><li>在路径<code>D:\BeawanDevelop\VSworkspace</code>下创建项目文件夹<code>CMakeDemo</code>，由于我电脑是Window环境，故我先用VS2017创建CMake项目，并将项目放到<code>CMakeDemo</code>文件夹下。<br><img src="/2018/11/20/VS2017开发跨平台C++项目/../../../../img/cmake/newCMake.png" alt="新建CMake项目"></li><li>新建的项目结构如下，习惯将默认生成的<code>CMakeProject</code>改成<code>src</code>目录，并修改<code>CMakeLists.txt</code>，主要修改了输出路径以及根据系统环境的判断，输出到不同的路径，配置如下：<br><img src="/2018/11/20/VS2017开发跨平台C++项目/../../../../img/cmake/projectDir.png" alt="CMake结构"><br><img src="/2018/11/20/VS2017开发跨平台C++项目/../../../../img/cmake/cmakeCfg.png" alt="CMakeLists配置"></li><li>选中<code>CMakeLists.txt</code>右击生成，会在目录<code>CMakeDemo</code>下输出win64目录，里面有生成的可执行程序。</li><li>也可以使用CMake工具生成VS2017项目，再用VS打开编译生成可执行程序。</li><li>接下来也需要在linux上编译刚才的项目。由于Win10现在支持Linux子系统，故我在微软商店下载安装了Ubuntu子系统。</li><li>首先需要C/C++的编译环境，Ubuntu提供了<code>build-essential</code>软件包，执行<code>apt-get install build-essential</code>进行安装。(Ubuntu软件源配置在<code>/etc/apt/sources.list</code>，为了安装最新的软件包，可以<code>apt-get update</code>更新软件源并<code>apt-get upgrade</code>升级已安装的软件，<code>apt-cache search package</code>搜索需要的软件包)</li><li>在目录<code>CMakeDemo</code>下创建<code>build-linux</code>文件夹供CMake输出makefile文件。</li><li>在Ubuntu中将目录切换至<code>build-linux</code>下，执行<code>cmake -DCMAKE_BUILD_TYPE=Release ../CMakeProject/</code>编译如下：<br><img src="/2018/11/20/VS2017开发跨平台C++项目/../../../../img/cmake/buildLinux.png" alt="CMake生成makefile"></li><li>执行<code>make</code>生成可执行文件，如下：<br><img src="/2018/11/20/VS2017开发跨平台C++项目/../../../../img/cmake/makeLinux.png" alt="makefile编译"></li><li>将目录切换至<code>linux64/Release/bin</code>下，执行<code>./CMakeProject</code>进行测试，如下：<br><img src="/2018/11/20/VS2017开发跨平台C++项目/../../../../img/cmake/makeTest.png" alt="测试"></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;最近有项目需要进行特定场景下的OCR，因此需要编译最新的OpenCV+Tesseract源码，涉及到Windows和Linux平台，对于Windows有VS IDE，可对于Linux一直没用过makefile，也没用过其他IDE，于是乎转向CMake。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="https://comlc.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
      <category term="开发环境" scheme="https://comlc.github.io/categories/%E5%85%B6%E4%BB%96/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="VS2017" scheme="https://comlc.github.io/tags/VS2017/"/>
    
      <category term="CMake" scheme="https://comlc.github.io/tags/CMake/"/>
    
  </entry>
  
  <entry>
    <title>记一次重装系统</title>
    <link href="https://comlc.github.io/2018/10/30/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    <id>https://comlc.github.io/2018/10/30/记一次重装系统/</id>
    <published>2018-10-30T04:30:00.000Z</published>
    <updated>2018-12-03T11:47:39.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>重装Windows操作系统。</p><a id="more"></a><h2 id="Windows10安装"><a href="#Windows10安装" class="headerlink" title="Windows10安装"></a>Windows10安装</h2><ol><li>到MSDN下载并安装windows10镜像<a href="https://msdn.itellyou.cn/" target="_blank" rel="noopener">https://msdn.itellyou.cn/</a>。</li><li>制作U盘启动，以前都是用UltraISO软碟通制作，但制作完发现在旧电脑可以引导并安装，在新电脑上无法引导安装。经查，发现新笔记本T480s在BIOS设置中有个安全启动项，需要关闭，可关闭之后还是无法引导。后来才知道有两种启动方式UEFI和Legacy。新电脑设置成只识别UEFI引导方式。网上也有说直接把U盘格式化成FAT32文件系统格式，然后把镜像解压到U盘上就行了。<blockquote><p>UEFI是新式的BIOS，Legacy是传统BIOS。你在UEFI模式下安装的系统，只能用UEFI模式引导；同理，如果你是在Legacy模式下安装的系统，也只能在legacy模式下进系统。UEFI只支持64为系统且磁盘分区必须为gpt模式，传统BIOS使用Int 13中断读取磁盘，每次只能读64KB，非常低效，而UEFI每次可以读1MB，载入更快。此外，Win8，更是进一步优化了UEFI支持，号称可以实现瞬时开机。</p></blockquote></li><li>UltraISO软碟通默认是Legacy引导方式，且文件系统格式是NTFS的。转而使用Rufus工具，下载地址<a href="https://rufus.ie/en_IE.html" target="_blank" rel="noopener">https://rufus.ie/en_IE.html</a>，制作完后顺利安装完系统。</li><li>附：装完系统发现T480s的F1-F12默认功能需要组合Fn才可以，直接按反而是调节音量等辅助功能，想反过来可以按Fn+Esc锁定Fn功能，或者在BIOS中可以修改，本人选择了后者。</li></ol><h2 id="开发环境及辅助软件"><a href="#开发环境及辅助软件" class="headerlink" title="开发环境及辅助软件"></a>开发环境及辅助软件</h2><ol><li>JDK安装及环境变量的配置，安装完到<code>C:\Windows\System32</code>目录下把java可执行文件删除。</li><li>Eclipse和MyEclipse的安装。Eclipse下载<a href="https://www.eclipse.org/downloads/packages/" target="_blank" rel="noopener">https://www.eclipse.org/downloads/packages/</a></li><li><code>Oracle 11g</code>、<code>Tomcat</code>、<code>PLSQL</code>、<code>DbVisualizer</code>安装，PLSQL会遇到32位的问题，需要下载<code>instantclient_11_2</code>放到目录<code>D:\ProgramFiles\oracle\product</code>，查询结果还会出现乱码问题，许添加环境变量<code>LANG=zh_CN.GBK</code>、<code>NLS_LANG=SIMPLIFIED CHINESE_CHINA.ZHS16GBK</code></li><li>下载<code>apache-maven-3.5.0-bin.zip</code>后并解压，新建环境变量<code>MAVEN_HOME</code>并添加bin到<code>Path</code>中，配置Maven本地仓库，打开文件<code>D:\ProgramFiles\apache-maven-3.5.0\conf\settings.xml</code>修改标签<code>&lt;localRepository&gt;D:\BeawanDevelop\Repositories\Maven&lt;/localRepository&gt;</code>，这里还可以在<code>mirrors</code>标签下添加一些国内镜像，在eclipse中配置maven</li><li><code>android-sdk-windows</code>、<code>Android Studio</code>、<code>TortoiseSVN</code>、<code>git</code>安装，SDK下载地址<a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">http://www.androiddevtools.cn/</a>，下载完解压，打开<code>SDK Manager</code>下载安装工具和API，新建环境变量<code>ANDROID_SDK_HOME</code>，并把<code>%ANDROID_SDK_HOME%\platform-tools</code>和<code>%ANDROID_SDK_HOME%\tools</code>添加到<code>Path</code>中，Studio安装完后导入之前版本的所有配置。新版本的Studio貌似都自带SDK，所以不需要单独下载SDK安装。</li><li><code>Node.js</code>、<code>npm</code>安装，下载地址<a href="https://nodejs.org/en/download/releases/" target="_blank" rel="noopener">https://nodejs.org/en/download/releases/</a>下载Nodejs，里面包含了npm</li><li><code>IntelliJ IDEA</code>安装，下载地址<a href="http://www.jetbrains.com/idea/download/previous.html" target="_blank" rel="noopener">http://www.jetbrains.com/idea/download/previous.html</a>，安装完后下载破解文件<a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a>，将下载的jar包放到IntelliJIDEA安装目录下的bin下面，并在文件<code>idea64.exe.vmoptions</code>和<code>idea64.exe.vmoptions</code>中添加<code>-javaagent:D:\ProgramFiles\IntelliJIDEA\bin\JetbrainsCrack-3.1-release-enc.jar</code>，重启软件，在进入出现有active code选择界面的时候写入下面注册代码：(到2099年到期)，最后导入之前版本的所有配置<br>ThisCrackLicenseId-{<br>“licenseId”:”ThisCrackLicenseId”,<br>“licenseeName”:”idea”,<br>“assigneeName”:””,<br>“assigneeEmail”:”<a href="mailto:idea@163.com" target="_blank" rel="noopener">idea@163.com</a>“,<br>“licenseRestriction”:”For This Crack, Only Test! Please support genuine!!!”,<br>“checkConcurrentUse”:false,<br>“products”:[<br>{“code”:”II”,”paidUpTo”:”2099-12-31”},<br>{“code”:”DM”,”paidUpTo”:”2099-12-31”},<br>{“code”:”AC”,”paidUpTo”:”2099-12-31”},<br>{“code”:”RS0”,”paidUpTo”:”2099-12-31”},<br>{“code”:”WS”,”paidUpTo”:”2099-12-31”},<br>{“code”:”DPN”,”paidUpTo”:”2099-12-31”},<br>{“code”:”RC”,”paidUpTo”:”2099-12-31”},<br>{“code”:”PS”,”paidUpTo”:”2099-12-31”},<br>{“code”:”DC”,”paidUpTo”:”2099-12-31”},<br>{“code”:”RM”,”paidUpTo”:”2099-12-31”},<br>{“code”:”CL”,”paidUpTo”:”2099-12-31”},<br>{“code”:”PC”,”paidUpTo”:”2099-12-31”}<br>],<br>“hash”:”2911276/0”,<br>“gracePeriodDays”:7,<br>“autoProlongated”:false}</li><li>Chrome浏览器安装，下载地址<a href="https://www.chromedownloads.net/chrome64win/" target="_blank" rel="noopener">https://www.chromedownloads.net/chrome64win/</a></li><li><code>Xmanager Enterprise 5</code>、<code>Notepad++</code>安装。</li><li>附：<code>SQLiteStudio</code>、<code>Robo 3T</code>、<code>Redis</code>、<code>MongoDB</code>、<code>PowerDesigner</code>、<code>Genymotion模拟器</code>、<code>Microsoft Visio</code>安装。由于win10支持linux子系统，所以在应用商店里下载Ubuntu。把<code>Redis</code>和<code>MongoDB</code>安装在Ubuntu子系统中。</li><li>Hexo+github搭建个人博客：<code>Hexo</code>安装，CMD命令行输入<code>npm install hexo -g</code>安装，安装完后自己新建hexo工作空间目录，<code>hexo init</code>初始化一个博客项目，<code>npm install</code>安装所需要的组件，<code>hexo generate</code>生成静态页面，<code>hexo server</code>本地启动服务，安装<code>npm install hexo-deployer-git  --save</code>自动部署发布工具，<code>hexo d</code>发布到github上，git上传项目到github上需要SSH Key，初次使用需进行如下配置<br><code>git config --global user.name &quot;用户名&quot;</code><br><code>git config --global user.email &quot;邮箱&quot;</code><br><code>cd ~/.ssh</code>检查.ssh文件夹是否存在，<code>ls</code>列出该文件夹下的内容<br>若没有SSH密钥，则<code>ssh-keygen -t rsa -C &quot;邮箱&quot;</code>后按三个回车键，都默认即可，在目录<code>C:\Users\comlc\.ssh</code>下会生成<code>id_rsa</code>和<code>id_rsa.pub</code><br>最后在GitHub上设置并新建SSH key即可</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;重装Windows操作系统。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="https://comlc.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
      <category term="开发环境" scheme="https://comlc.github.io/categories/%E5%85%B6%E4%BB%96/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="windows安装" scheme="https://comlc.github.io/tags/windows%E5%AE%89%E8%A3%85/"/>
    
      <category term="windows开发环境" scheme="https://comlc.github.io/tags/windows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis简介</title>
    <link href="https://comlc.github.io/2018/10/20/MyBatis%E7%AE%80%E4%BB%8B/"/>
    <id>https://comlc.github.io/2018/10/20/MyBatis简介/</id>
    <published>2018-10-20T03:00:00.000Z</published>
    <updated>2018-12-03T12:48:30.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>介绍MyBatis的定义，与传统JDBC相比有哪些优点及缺点，为我们提供了哪些功能。</p><a id="more"></a><h2 id="MyBatis简介"><a href="#MyBatis简介" class="headerlink" title="MyBatis简介"></a>MyBatis简介</h2><blockquote><p>MyBatis是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis可以使用简单的XML或注解来配置和映射原生信息，将接口和Java的POJOs(Plain Old Java Objects，普通的Java对象)映射成数据库中的记录。  </p></blockquote><ol><li>我们将从What、How、Why三方面来认识这个框架。What讲解的是框架的定义，框架产生的原因和解决的问题，以及框架为我们提供了哪些功能。How讲解的是我们如何去使用框架。Why即是从源码的角度去剖析框架的原理.</li><li>最后总结一些框架设计的原则和经验。</li><li>MyBatis框架整体设计，如下图所示：<br><img src="/2018/10/20/MyBatis简介/../../../../img/MyBatis/main.png" alt="MyBatis框架"></li></ol><h2 id="传统JDBC的问题"><a href="#传统JDBC的问题" class="headerlink" title="传统JDBC的问题"></a>传统JDBC的问题</h2><ol><li>数据库连接频繁的开启和关闭本身就造成了资源的浪费，影响系统的性能。</li><li>JDBC操作数据库时SQL语句写在Java代码中，不利于维护且可读性较差，且多条件查询时，动态SQL的编写不方便，另外在一些通用查询语句复用性上不是很好。</li><li>对ResultSet结果集的映射和结果缓存比较麻烦。</li></ol><h2 id="MyBatis的出现"><a href="#MyBatis的出现" class="headerlink" title="MyBatis的出现"></a>MyBatis的出现</h2><ol><li>我们可以通过DataSource进行隔离解耦，我们统一从DataSource里面获取数据库连接，DataSource具体由DBCP实现还是由容器的JNDI实现都可以，所以我们将DataSource的具体实现通过让用户配置来应对变化。</li><li>MyBatis使用Mapper.xml配置文件来存放SQL语句，方便统一管理维护。</li><li>MyBatis提供了动态SQL的功能。并且可以使用<sql>标签编写SQL片段来实现复用。</sql></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;介绍MyBatis的定义，与传统JDBC相比有哪些优点及缺点，为我们提供了哪些功能。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="https://comlc.github.io/categories/JavaEE/"/>
    
      <category term="MyBatis相关" scheme="https://comlc.github.io/categories/JavaEE/MyBatis%E7%9B%B8%E5%85%B3/"/>
    
      <category term="功能篇" scheme="https://comlc.github.io/categories/JavaEE/MyBatis%E7%9B%B8%E5%85%B3/%E5%8A%9F%E8%83%BD%E7%AF%87/"/>
    
    
      <category term="MyBatis" scheme="https://comlc.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>AndroidStudio上传SVN项目</title>
    <link href="https://comlc.github.io/2018/03/24/AndroidStudio%E4%B8%8A%E4%BC%A0SVN%E9%A1%B9%E7%9B%AE/"/>
    <id>https://comlc.github.io/2018/03/24/AndroidStudio上传SVN项目/</id>
    <published>2018-03-24T00:30:30.000Z</published>
    <updated>2018-11-01T02:37:43.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Android Studio上使用SVN上传项目源码。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>下载并安装Android Studio。</li><li>下载并安装TortoiseSVN客户端。</li><li>在Studio中配置SVN。依次点击<code>File&gt;Settings&gt;Subversion</code>，在<code>Use command line client</code>中添加<code>svn.exe</code>，其在TortoiseSVN的安装路径，如<code>D:\ProgramFiles\TortoiseSVN\bin\svn.exe</code>。若是不存在<code>svn.exe</code>，则安装TortoiseSVN未安装command line功能，需重新安装。</li></ol><h2 id="将Studio项目与SVN关联"><a href="#将Studio项目与SVN关联" class="headerlink" title="将Studio项目与SVN关联"></a>将Studio项目与SVN关联</h2><ol><li>在关联SVN前，先添加忽略文件。打开文件<code>.idea/workspace.xml</code>，找到标签<code>&lt;ignored path=&quot;.idea/workspace.xml&quot; /&gt;</code>，在后面添加如下忽略配置：<br><code>&lt;ignored path=&quot;build/&quot; /&gt;</code><br><code>&lt;ignored path=&quot;.gradle/&quot; /&gt;</code><br><code>&lt;ignored path=&quot;.idea/&quot; /&gt;</code><br><code>&lt;ignored path=&quot;app/build&quot; /&gt;</code><br><code>&lt;ignored path=&quot;模块名/build&quot; /&gt;(若有其他模块添加)</code><br><code>&lt;ignored path=&quot;local.properties&quot; /&gt;</code><br><code>&lt;ignored mask=&quot;*.iml&quot; /&gt;</code><br>点击保存，Studio可能需要重新启动。</li><li>依次点击<code>VCS&gt;Import into Version Control&gt;Share Project(Subversion)</code>，新版本的Studio中可能没有<code>Share Project(Subversion)</code>则选择<code>Import into Subversion</code>，在弹出的窗口中新增SVN服务器路径，在<code>Define share target</code>中选择中间的选项，在<code>Subversion Working Copy Format</code>中建议选择<code>1.8format</code>。</li></ol><h2 id="提交项目代码"><a href="#提交项目代码" class="headerlink" title="提交项目代码"></a>提交项目代码</h2><p>首次提交代码，我这里直接用TortoiseSVN客户端来提交，找到项目所在目录，右击项目文件夹，Commit项目文件，上传成功后过几分钟可以看到Studio中文件颜色因提交代码而改变。</p><h2 id="解除SVN关联"><a href="#解除SVN关联" class="headerlink" title="解除SVN关联"></a>解除SVN关联</h2><ol><li>打开文件<code>.idea/vcs.xml</code>，将标签<code>&lt;mapping directory=&quot;&quot; vcs=&quot;svn&quot; /&gt;</code>中的<code>svn</code>去掉，然后点击保存即可。</li><li>打开项目所在文件夹，删除.svn文件夹。</li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Android Studio上使用SVN上传项目源码。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://comlc.github.io/categories/Android/"/>
    
      <category term="其他相关" scheme="https://comlc.github.io/categories/Android/%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="AndroidStudio" scheme="https://comlc.github.io/tags/AndroidStudio/"/>
    
      <category term="SVN" scheme="https://comlc.github.io/tags/SVN/"/>
    
  </entry>
  
  <entry>
    <title>SQLCipher-JDBC编译打包</title>
    <link href="https://comlc.github.io/2018/03/19/SQLCipher-JDBC%E7%BC%96%E8%AF%91%E6%89%93%E5%8C%85/"/>
    <id>https://comlc.github.io/2018/03/19/SQLCipher-JDBC编译打包/</id>
    <published>2018-03-19T07:30:30.000Z</published>
    <updated>2018-12-03T11:46:57.901Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前在<code>Windows下编译SQLCipher源码</code>这篇文章中介绍了SQLCipher的编译过程，最终编译得到SQLCipher的静态库和动态库文件。由于最终是想通过Java JNI调用SQLCipher库，从而实现本地SQLite库的加解密。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol><li>Eclipse配置Maven环境。</li><li>下载sqlcipher-jdbc源码，地址是<a href="https://github.com/decamp/sqlcipher-jdbc" target="_blank" rel="noopener">https://github.com/decamp/sqlcipher-jdbc</a>，该作者只编译了OS X版本的库。对于Windows和Linux的库只能自己编译咯。</li><li>将源码导入到Eclipse中，项目结构如下图所示：<br><img src="/2018/03/19/SQLCipher-JDBC编译打包/../../../../img/SQLCipherJdbc/img1.png" alt="sqlcipher-jdbc工程结构"></li><li>查看项目中<code>org.sqlite.core.NativeDB</code>类，这就是JNI的Java部分，里面的每个方法都是native声明的。<br>查看<code>org/sqlite/core</code>目录下的NativeDB.c文件，这就是调用本地库的C代码实现部分。</li><li>生成C语言头文件，打开CMD命令窗口，切换到项目classes根目录，如<code>D:\BeawanDevelop\workspace\sqlcipher-jdbc-master\target\classes</code>，执行命令<code>javah -classpath . -jni org.sqlite.core.NativeDB</code>后会在项目classes根目录下生成<code>org_sqlite_core_NativeDB.h</code>头文件。</li></ol><h2 id="编译JDBC源码"><a href="#编译JDBC源码" class="headerlink" title="编译JDBC源码"></a>编译JDBC源码</h2><ol><li>VS2010新建一个<code>Win32项目</code>类型的空项目，选择应用程序类型为DLL。</li><li>将之前编译SQLCipher生成的<code>libeay32.lib</code>、<code>libeay32.dll</code>、<code>ssleay32.lib</code>、<code>ssleay32.dll</code>、<code>sqlite3.c</code>、<code>sqlite3.def</code>、<code>sqlite3.h</code>、<code>sqlite3ext.h</code>库文件复制到VS工程根目录下。<br>将sqlcipher-jdbc源码中的<code>NativeDB.c</code>和生成的头文件<code>org_sqlite_core_NativeDB.h</code>复制到VS工程根目录下。</li><li>在VS工程中右击添加现有项，项目结构如下图所示：<br><img src="/2018/03/19/SQLCipher-JDBC编译打包/../../../../img/SQLCipherJdbc/img2.png" alt="VS工程结构"></li><li>配置项目属性页，如下图所示：<br><img src="/2018/03/19/SQLCipher-JDBC编译打包/../../../../img/SQLCipherJdbc/img3.png" alt="VC++目录设置"><br><img src="/2018/03/19/SQLCipher-JDBC编译打包/../../../../img/SQLCipherJdbc/img4.png" alt="预处理器设置"><br><img src="/2018/03/19/SQLCipher-JDBC编译打包/../../../../img/SQLCipherJdbc/img5.png" alt="链接器输入设置"></li><li>默认是32位编译环境，需手动添加64位编译环境。</li><li>在64位编译环境下，点击生成，会在项目根目录下生成x64目录，在目录<code>x64\Debug</code>下会有<code>sqlcipher-jdbc.dll</code>动态链接库文件。</li><li>注意：由于<code>NativeDB.h</code>头文件中有<code>#include &lt;jni.h&gt;</code>会报错找不到头文件，需要到JDK安装路径<code>D:\ProgramFiles\java1.7\jdk1.7\include</code>，将<code>jni.h</code>和<code>win32\jni_md.h</code>头文件复制到VS安装目录下<code>D:\ProgramFiles\VisualStudio2010\VC\include</code>，并重新打开该项目。</li></ol><h2 id="测试JDBC源码"><a href="#测试JDBC源码" class="headerlink" title="测试JDBC源码"></a>测试JDBC源码</h2><ol><li>在Eclipse的sqlcipher-jdbc项目中，新增Windows本地库目录，如下图所示：<br><img src="/2018/03/19/SQLCipher-JDBC编译打包/../../../../img/SQLCipherJdbc/img6.png" alt="Windows本地库目录"></li><li><p>编写测试类JDBCTest，如下所示：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sqlite.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">String dbFilePath = <span class="string">"D:\\BeawanDevelop\\SQLiteDB\\encrypt.db"</span>;</span><br><span class="line">Class.forName(<span class="string">"org.sqlite.JDBC"</span>);</span><br><span class="line">Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">props.put( <span class="string">"key"</span>, <span class="string">"comlc"</span>);</span><br><span class="line">conn = DriverManager.getConnection(<span class="string">"jdbc:sqlcipher:"</span> + dbFilePath, props);</span><br><span class="line">System.out.println(<span class="string">"Opened database successfully"</span>);</span><br><span class="line">stmt = conn.createStatement();</span><br><span class="line">String sql = <span class="string">"CREATE TABLE COMPANY4 "</span> +</span><br><span class="line"><span class="string">"(ID INT PRIMARY KEY     NOT NULL,"</span> +</span><br><span class="line"><span class="string">" NAME           TEXT    NOT NULL, "</span> + </span><br><span class="line"><span class="string">" AGE            INT     NOT NULL, "</span> + </span><br><span class="line"><span class="string">" ADDRESS        CHAR(50), "</span> + </span><br><span class="line"><span class="string">" SALARY         REAL)"</span>; </span><br><span class="line">stmt.executeUpdate(sql);</span><br><span class="line">stmt.close();</span><br><span class="line">conn.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Maven生成sqlcipher-jdbc.jar包，可以供其他应用程序调用了。</p></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;之前在&lt;code&gt;Windows下编译SQLCipher源码&lt;/code&gt;这篇文章中介绍了SQLCipher的编译过程，最终编译得到SQLCipher的静态库和动态库文件。由于最终是想通过Java JNI调用SQLCipher库，从而实现本地SQLite库的加解密。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="https://comlc.github.io/categories/JavaEE/"/>
    
      <category term="SQlite相关" scheme="https://comlc.github.io/categories/JavaEE/SQlite%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="SQLCipher-JDBC" scheme="https://comlc.github.io/tags/SQLCipher-JDBC/"/>
    
      <category term="Visual Studio" scheme="https://comlc.github.io/tags/Visual-Studio/"/>
    
      <category term="DLL编译" scheme="https://comlc.github.io/tags/DLL%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Windows下编译SQLCipher源码</title>
    <link href="https://comlc.github.io/2018/03/18/Windows%E4%B8%8B%E7%BC%96%E8%AF%91SQLCipher%E6%BA%90%E7%A0%81/"/>
    <id>https://comlc.github.io/2018/03/18/Windows下编译SQLCipher源码/</id>
    <published>2018-03-18T13:20:10.000Z</published>
    <updated>2018-12-03T11:47:07.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近公司分配了部分员工去做行业分析相关模块，他们研究了一段时间之后，形成了一定规模量的数据。考虑到行业分析数据的安全性和可移植性，想到利用SQLite这款轻量级数据库。可是由于SQLite本身不支持加解密功能，虽然提供了加解密的接口，于是乎考虑使用SQLCipher。</p><a id="more"></a><blockquote><p>SQLCipher分为收费版本和免费版本，官网介绍的区别为：只是集成起来更简单，不用再添加openssl依赖库，而且编译速度更快，从功能来说没有任何区别。SQLCipher使用256-bit AES加密。</p></blockquote><h2 id="OpenSSL编译"><a href="#OpenSSL编译" class="headerlink" title="OpenSSL编译"></a>OpenSSL编译</h2><blockquote><p>OpenSSL（Open Secure Sockets Layer）是一个安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及SSL协议，并提供丰富的应用程序供测试或其它目的使用。<br>OpenSSL整个软件包大概可以分成三个主要的功能部分：SSL协议库、应用程序以及密码算法库</p></blockquote><ol><li>下载并安装<a href="https://www.activestate.com/activeperl" target="_blank" rel="noopener">Activestate Perl</a>。下载<a href="https://www.openssl.org/source/" target="_blank" rel="noopener">OpenSSL源码</a>并解压，我下载的是openssl-1.0.1p.tar.gz。安装Visual Studio2010。</li><li>配置环境变量，我的环境变量如下：<br><code>D:\ProgramFiles\VisualStudio2010\VC\bin</code><br><code>D:\ProgramFiles\VisualStudio2010\Common7\IDE</code><br><code>D:\ProgramFiles\VisualStudio2010\VC\bin\amd64</code></li><li><code>Win+R</code>打开cmd命令行窗口，运行<code>vcvars32</code>进入32位编译环境。</li><li>切换到OpenSSL解压目录，依次执行以下命令：<br><code>perl Configure VC-WIN32 --prefix=D:\BeawanDevelop\VSworkspace\OpenSSL\build32</code><br><code>ms\do_ms</code><br><code>nmake -f ms\nt.mak</code><br><code>nmake -f ms\nt.mak test</code><br><code>nmake -f ms\nt.mak install</code><br><code>nmake -f ms\ntdll.mak</code><br><code>nmake -f ms\ntdll.mak test</code><br><code>nmake -f ms\ntdll.mak install</code></li><li>查看目录<code>D:\BeawanDevelop\VSworkspace\OpenSSL\build32</code>下是否生成<code>libeay32.lib、ssleay32.lib、libeay32.dll、ssleay32.dll</code></li><li>运行<code>vcvars64</code>进入64位编译环境（如果需要编译64位版本）</li><li>依次执行以下命令：<br><code>perl Configure VC-WIN64A --prefix=D:\BeawanDevelop\VSworkspace\OpenSSL\build64</code><br><code>ms\do_win64a</code><br><code>nmake -f ms\nt.mak clean</code><br><code>nmake -f ms\ntdll.mak clean</code><br><code>nmake -f ms\nt.mak</code><br><code>nmake -f ms\nt.mak install</code><br><code>nmake -f ms\ntdll.mak</code><br><code>nmake -f ms\ntdll.mak install</code></li><li>查看目录<code>D:\BeawanDevelop\VSworkspace\OpenSSL\build64</code>下是否生成<code>libeay32.lib、ssleay32.lib、libeay32.dll、ssleay32.dll</code></li></ol><h2 id="MinGW安装"><a href="#MinGW安装" class="headerlink" title="MinGW安装"></a>MinGW安装</h2><blockquote><p>MinGW（Minimalist GNU on Windows）是一个可以在windows下编译linux程序的仿真linux编译环境，他提供了linux下的C、C++头文件、系统库和一些linux下的编译工具集合，例如gcc、g++和make工具。使得编译出来的二进制可以在windows上运行。（此前的 cygwin 虽然也是 GNU 的 Windows 移植，但是 cygwin 是有版权的，不是 GNU）。</p></blockquote><ol><li>下载<a href="https://sourceforge.net/projects/mingw/files/" target="_blank" rel="noopener">32位MinGW</a>，我下载的是mingw-get-setup.exe。<a href="https://sourceforge.net/projects/mingw-w64/files/?source=navbar" target="_blank" rel="noopener">64位MinGW</a>提供在线安装，下载下来的文件安装有问题，需要下载最新版本的，这需要翻墙</li><li>安装完成后，配置环境变量如下：<br><code>C:\MinGW\msys\1.0\bin</code><br><code>C:\MinGW\bin</code></li><li>打开MinGW Installation Manager，将Basic Setup中的工具包都安装上（另外gcc、msys、tclsh、mingw等工具包必须要安装），如下图：<br><img src="/2018/03/18/Windows下编译SQLCipher源码/../../../../img/SQLCipher/MinGW.png" alt="MinGW Installation Manager界面"></li><li>工具包具体安装方法：右击某个工具包选择Mark for Installation，然后点击软件菜单里面里面的installation中的Apply Changes</li></ol><h2 id="编译SQLCipher"><a href="#编译SQLCipher" class="headerlink" title="编译SQLCipher"></a>编译SQLCipher</h2><blockquote><p>由于官网MinGW w64版本提供的是在线安装的exe文件，下载下来安装文件会报错，需要翻墙下载最新版本，所以以下编译及测试均为32位的。</p></blockquote><ol><li>下载<a href="https://github.com/sqlcipher/sqlcipher" target="_blank" rel="noopener">SQLCipher</a>源码并解压，然后将OpenSSL编译安装生成的<code>libeay32.lib、ssleay32.lib、libeay32.dll、ssleay32.dll</code>文件复制到SQLCipher主目录（注：这里编译的是32位，所以复制的库文件也是32位的，包括下面./configure命令所需的OpenSSL头文件也是指定的32位，具体查看文件位数命令<code>file libeay32.dll</code>）</li><li><code>Win+R</code>打开cmd命令行窗口，切换到msys的安装目录<code>C:\MinGW\msys\1.0</code>后，运行<code>msys.bat</code></li><li>在弹出的MINGW32新窗口中，切换目录到SQLCipher主目录<code>D:\BeawanDevelop\VSworkspace\OpenSSL\sqlcipher-master</code></li><li>执行命令<code>./configure --with-crypto-lib=none --disable-tcl CFLAGS=&quot;-DSQLITE_HAS_CODEC -DSQLCIPHER_CRYPTO_OPENSSL -I/d/BeawanDevelop/VSworkspace/OpenSSL/build32/include /d/BeawanDevelop/VSworkspace/OpenSSL/sqlcipher-master/libeay32.dll -L/d/BeawanDevelop/VSworkspace/OpenSSL/sqlcipher-master/ -static-libgcc&quot; LDFLAGS=&quot;-leay32&quot;</code></li><li>依次执行以下命令：<br><code>make clean</code><br><code>make sqlite3.c</code><br><code>make</code><br><code>make dll</code></li><li>查看SQLCipher目录下是否生成<code>sqlite3.c、sqlite3.h、sqlite3.def、sqlite3ext.h</code>文件</li></ol><h2 id="测试SQLCipher"><a href="#测试SQLCipher" class="headerlink" title="测试SQLCipher"></a>测试SQLCipher</h2><ol><li>打开Visual Studio2010创建Win32控制台应用程序，然后将SQLCipher主目录下的<code>sqlite3.c、sqlite3.h、sqlite3.def、sqlite3ext.h、libeay32.lib、ssleay32.lib、libeay32.dll、ssleay32.dll</code>文件复制到测试工程的主目录</li><li>添加文件到项目中，如下图所示：<br><img src="/2018/03/18/Windows下编译SQLCipher源码/../../../../img/SQLCipher/SQLCipherTest-Menu.png" alt="SQLCipher测试工程目录结构"></li><li>在测试项目中添加如下宏定义：<br><code>SQLITE_HAS_CODEC=1</code><br><code>CODEC_TYPE=CODEC_TYPE_AES128</code><br><code>SQLITE_CORE</code><br><code>THREADSAFE</code><br><code>SQLITE_SECURE_DELETE</code><br><code>SQLITE_SOUNDEX</code><br><code>SQLITE_ENABLE_COLUMN_METADATA</code></li><li>添加附加依赖项和模块定义文件，如下图所示：<br><img src="/2018/03/18/Windows下编译SQLCipher源码/../../../../img/SQLCipher/setting1.png" alt="SQLCipher依赖库配置"></li><li>添加OpenSSL头文件依赖，如下图所示：<br><img src="/2018/03/18/Windows下编译SQLCipher源码/../../../../img/SQLCipher/setting2.png" alt="OpenSSL头文件依赖"></li><li>新增测试代码，如下所示：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"sqlite3.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">callback</span><span class="params">(<span class="keyword">void</span> *NotUsed, <span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">char</span> **azColName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s = %s\n"</span>, azColName[i], argv[i] ? argv[i] : <span class="string">"NULL"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line"></span><br><span class="line">sqlite3 * db;</span><br><span class="line"><span class="keyword">if</span> (sqlite3_open(<span class="string">"test.db"</span>, &amp;db) == SQLITE_OK) &#123;</span><br><span class="line"><span class="keyword">int</span> n = sqlite3_key(db, <span class="string">"123"</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (sqlite3_exec(db, (<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="string">"CREATE TABLE StaffMember (sid varchar(256), name varchar(20),age varchar(20));"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == SQLITE_OK) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Created Table\n"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">if</span> (sqlite3_exec(db, (<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="string">"insert into StaffMember(sid, name, age) values('001', 'comlc', '123')"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == SQLITE_OK)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Sent Select\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sqlite3_exec(db, (<span class="keyword">const</span> <span class="keyword">char</span>*)<span class="string">"SELECT * FROM StaffMember;"</span>, callback, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == SQLITE_OK) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Sent Select\n"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">sqlite3_close(db);  <span class="comment">//close it up properly</span></span><br><span class="line"><span class="keyword">int</span> a;  </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);<span class="comment">//没有此行代码，运行窗口出现后会马山消失。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="附：64位版本编译及测试"><a href="#附：64位版本编译及测试" class="headerlink" title="附：64位版本编译及测试"></a>附：64位版本编译及测试</h2><blockquote><p>我选择更换编译环境的安装方法，先安装MSYS2然后再安装MinGW。<br>MSYS2是Windows下的类Unix命令行运行环境。它提供了pacman包管理器，用pacman可以方便你安装其它程序包或者工具。<br>MINGW32 和 MINGW64 包含GNU编译工具集合，可以用它编译C/C++， Fortran，和其它源代码。它们的区别之处就是，分别是32位和64位系统下的版本。它们编译的代码，即使没有MINGW32，MINGW64或者MSYS2提供的运行时库，也可以在Windows下运行。GCC既可以被MSYS2也可以被Window原生CMD命令调用。我乐意选择MSYS2，是因为它建立的环境，提供了包管理器，可以方便安装其它编码工具（例如，autoconf 和 automake）。 当然了，MINGW32 和 MINGW64 也可以单独安装，即使没有 MSYS2。但是，我还是强烈建议使用MSYS2安装。</p></blockquote><ol><li>下载<a href="https://sourceforge.net/projects/msys2/" target="_blank" rel="noopener">MSYS2</a>并安装，我下载的是<code>msys2-x86_64-yyyyMMdd.exe</code></li><li><p>安装完成后在MSYS2的安装目录<code>C:\msys64\etc\pacman.d</code>下修改pacman数据源，如下：<br> <code>mirrorlist.msys</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##中国科学技术大学开源软件镜像</span><br><span class="line">Server = http://mirrors.ustc.edu.cn/msys2/msys/$arch/</span><br><span class="line">##北京理工大学镜像</span><br><span class="line">Server = http://mirror.bit.edu.cn/msys2/REPOS/MSYS2/$arch</span><br><span class="line">##日本北陆先端科学技术大学院大学 sourceforge 镜像</span><br><span class="line">Server = http://jaist.dl.sourceforge.net/project/msys2/REPOS/MSYS2/$arch</span><br><span class="line">##The UK Mirror Service Sourceforge mirror</span><br><span class="line">Server = http://www.mirrorservice.org/sites/download.sourceforge.net/pub/sourceforge/m/ms/msys2/REPOS/MSYS2/$arch</span><br><span class="line">## Primary</span><br><span class="line">Server = ftp://148.251.42.38/MSYS2/$arch</span><br><span class="line">## Sourceforge.net</span><br><span class="line">Server = http://downloads.sourceforge.net/project/msys2/REPOS/MSYS2/$arch</span><br></pre></td></tr></table></figure><p> <code>mirrorlist.mingw32</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##中国科学技术大学开源软件镜像</span><br><span class="line">Server = http://mirrors.ustc.edu.cn/msys2/mingw/i686/</span><br><span class="line">##北京理工大学镜像</span><br><span class="line">Server = http://mirror.bit.edu.cn/msys2/REPOS/MINGW/i686</span><br><span class="line">##日本北陆先端科学技术大学院大学 sourceforge 镜像</span><br><span class="line">Server = http://jaist.dl.sourceforge.net/project/msys2/REPOS/MINGW/i686</span><br><span class="line">##The UK Mirror Service Sourceforge mirror</span><br><span class="line">Server = http://www.mirrorservice.org/sites/download.sourceforge.net/pub/sourceforge/m/ms/msys2/REPOS/MINGW/i686</span><br><span class="line">## Primary</span><br><span class="line">Server = ftp://148.251.42.38/MINGW/i686</span><br><span class="line">## Sourceforge.net</span><br><span class="line">Server = http://downloads.sourceforge.net/project/msys2/REPOS/MINGW/i686</span><br></pre></td></tr></table></figure><p> <code>mirrorlist.mingw64</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">##中国科学技术大学开源软件镜像</span><br><span class="line">Server = http://mirrors.ustc.edu.cn/msys2/mingw/x86_64/</span><br><span class="line">##北京理工大学镜像</span><br><span class="line">Server = http://mirror.bit.edu.cn/msys2/REPOS/MINGW/x86_64</span><br><span class="line">##日本北陆先端科学技术大学院大学 sourceforge 镜像</span><br><span class="line">Server = http://jaist.dl.sourceforge.net/project/msys2/REPOS/MINGW/x86_64</span><br><span class="line">##The UK Mirror Service Sourceforge mirror</span><br><span class="line">Server = http://www.mirrorservice.org/sites/download.sourceforge.net/pub/sourceforge/m/ms/msys2/REPOS/MINGW/x86_64</span><br><span class="line">## Primary</span><br><span class="line">Server = ftp://148.251.42.38/MINGW/x86_64</span><br><span class="line">## Sourceforge.net</span><br><span class="line">Server = http://downloads.sourceforge.net/project/msys2/REPOS/MINGW/x86_64</span><br></pre></td></tr></table></figure></li><li><p>在开始菜单中打开<code>MSYS2 MSYS</code>命令窗口</p></li><li>执行<code>pacman -Sy</code>更新本地包数据，执行<code>pacman -S --needed filesystem msys2-runtime bash libreadline libiconv libarchive libgpgme libcurl pacman ncurses libintl</code>升级核心包</li><li>关闭所有 MSYS2 shell，然后运行<code>C:\msys64\autorebase.bat</code></li><li>打开<code>MSYS2 MSYS</code>命令窗口，执行<code>pacman -Su</code>升级其他包</li><li>安装成功后，msys64目录下会出现<code>mingw32.exe</code>、<code>mingw64.exe</code>和<code>msys2.exe</code></li><li>执行<code>pacman -S gcc</code>安装gcc</li><li>对于32位系统，安装MinGW32位，执行<code>pacman -S  mingw-w64-i686-toolchain</code></li><li>对于64位系统，安装MinGW64位，执行<code>pacman -S  mingw-w64-x86_64-toolchain</code></li><li>执行<code>pacman -S msys/make</code>安装make</li><li>添加环境变量：<code>C:\msys64\mingw64\bin</code></li><li>安装完成后执行<code>gcc -v</code>验证安装成功</li><li>编译32位SQLCipher库，在开始菜单中打开<code>MSYS2 MinGW 32-bit</code>命令窗口，参照上面的编译SQLCipher章节</li><li>编译64位SQLCipher库，在开始菜单中打开MSYS2 MinGW 64-bit命令窗口，参照上面的编译SQLCipher章节，不同的是复制OpenSSL的库是64位的，以及执行的<code>.configure</code>命令如下：<br><code>./configure --with-crypto-lib=none --disable-tcl CFLAGS=&quot;-DSQLITE_HAS_CODEC -DSQLCIPHER_CRYPTO_OPENSSL -I/d/BeawanDevelop/VSworkspace/OpenSSL/opensslbuild64/include /d/BeawanDevelop/VSworkspace/OpenSSL/sqlcipher-master/libeay32.dll -L/d/BeawanDevelop/VSworkspace/OpenSSL/sqlcipher-master/ -static-libgcc&quot; LDFLAGS=&quot;-leay32&quot;</code></li><li>分别测试32位库和64位库，参照上面测试SQLCipher章节，在测试64位库的时候，需要配置VS2010的x64环境，如下图所示：<br><img src="/2018/03/18/Windows下编译SQLCipher源码/../../../../img/SQLCipher/setting3.png" alt="VS2010 x64位编译环境"></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;最近公司分配了部分员工去做行业分析相关模块，他们研究了一段时间之后，形成了一定规模量的数据。考虑到行业分析数据的安全性和可移植性，想到利用SQLite这款轻量级数据库。可是由于SQLite本身不支持加解密功能，虽然提供了加解密的接口，于是乎考虑使用SQLCipher。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="https://comlc.github.io/categories/JavaEE/"/>
    
      <category term="SQlite相关" scheme="https://comlc.github.io/categories/JavaEE/SQlite%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="SQLCipher" scheme="https://comlc.github.io/tags/SQLCipher/"/>
    
      <category term="OpenSSL" scheme="https://comlc.github.io/tags/OpenSSL/"/>
    
      <category term="MSYS2" scheme="https://comlc.github.io/tags/MSYS2/"/>
    
      <category term="MinGW" scheme="https://comlc.github.io/tags/MinGW/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu子系统安装Websphere8.5.5</title>
    <link href="https://comlc.github.io/2018/03/02/Ubuntu%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85Websphere8.5.5/"/>
    <id>https://comlc.github.io/2018/03/02/Ubuntu子系统安装Websphere8.5.5/</id>
    <published>2018-03-02T01:55:04.000Z</published>
    <updated>2018-12-03T11:47:25.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前段时间通过Win10升级助手升级了最新的Win10系统，发现应用商店里居然有Linux子系统。本着好奇心就下载体验了下，省去了安装VMware虚拟机。</p><a id="more"></a><blockquote><p>Windows Subsystem for Linux（简称WSL）是一个为在Windows 10上能够原生运行Linux二进制可执行文件（ELF格式）的兼容层。它是由微软与Canonical公司合作开发，目标是使纯正的Ubuntu 14.04 “Trusty Tahr”映像能下载和解压到用户的本地计算机，并且映像内的工具和实用工具能在此子系统上原生运行。</p></blockquote><h2 id="Ubuntu子系统安装"><a href="#Ubuntu子系统安装" class="headerlink" title="Ubuntu子系统安装"></a>Ubuntu子系统安装</h2><ol><li>Ubuntu子系统的安装可以参考下面的网址，不过不用更新到Insider预览版了，最新正式版已经提供相关功能。<br><a href="https://linux.cn/article-7209-1.html" target="_blank" rel="noopener">https://linux.cn/article-7209-1.html</a></li><li>通过Xstart安装Websphere<br><a href="https://www.cnblogs.com/xuxiuxiu/p/5832211.html" target="_blank" rel="noopener">https://www.cnblogs.com/xuxiuxiu/p/5832211.html</a><br>Xstart远程连接配置如下：<br><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img1.png" alt="Xstart远程连接配置"></li><li>遇到的问题<br>Installation Manager静默安装完后，需要通过Xstart执行/opt/IBM/InstallationManager/eclipse下的launcher，执行过程中会报缺失libgtk-x11-2.0.so.0库。网上说需要安装sudo apt-get install ia32-libs ia32-libs-gtk。实际上，ubuntu需要的早已经不是这俩库了，实际上我们需要的是：sudo apt-get install libgtk2.0-0。</li></ol><h2 id="安装WAS"><a href="#安装WAS" class="headerlink" title="安装WAS"></a>安装WAS</h2><ol><li>从Ubuntu 6.10开始，默认使用dash(theDebian Almquist Shell)而不是bash(the GNUBourne-Again Shell)。所以在安装之前需要将默认的shell改成bash<br><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img2.png" alt="bash配置"></li><li>进入到IM安装目录<code>/opt/IBM/InstallationManager/eclipse</code>，用XStart执行命令<code>./launcher</code>进入was的图形化安装向导。</li><li>安装完并创建节点AppSrv01后，进入到/opt/IBM/WebSphere/AppServer/profiles/AppSrv01/bin目录，执行./startServer.sh server1启动服务。</li><li>若报错<code>Program exiting with error: java.lang.UnsatisfiedLinkError:Ws60ProcessManagement(/opt/IBM/WebSphere/AppServer/lib/native/linux/x86_64/libWs60ProcessManagement.so: cannot enable executable stack as shared object requires: Invalid argument)</code><br><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img3.png" alt="报错信息"></li><li>解决办法：执行命令<code>execstack -c /opt/IBM/WebSphere/AppServer/lib/native/linux/x86_64/libWs60ProcessManagement.so</code>后，再重新启动服务。</li></ol><h2 id="设置WAS使用SDK7"><a href="#设置WAS使用SDK7" class="headerlink" title="设置WAS使用SDK7"></a>设置WAS使用SDK7</h2><ol><li>进入WebSphere安装目录，如<code>/opt/IBM/WebSphere/AppServer/bin</code>，执行命令：<code>./managesdk.sh -listAvailable</code><br><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img4.png" alt="命令截图"></li><li>设置当新建profile时默认使用sdk7，执行命令：<code>./managesdk.sh -setnewprofiledefault -sdkname 1.7.1_64</code><br><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img5.png" alt="命令截图"></li><li>设置当前所有profile使用sdk7<br><strong>提示：有些linux环境设置profile使用sdk7后会导致was崩溃，如遇崩溃，则卸载并重装was至此步骤后，先执行下面的解决方案，再执行此步操作</strong><br><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img6.png" alt="命令截图"></li><li>执行命令：<code>./managesdk.sh -enableProfileAll -sdkName 1.7.1_64 -user wasadmin -password wasadmin</code><br><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img7.png" alt="命令截图"></li><li>查看所有profile 的sdk版本, 都为1.7时说明设置成功，执行命令：<code>./managesdk.sh -listEnabledProfileAll</code><br><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img8.png" alt="命令截图"></li></ol><h2 id="卸载WAS"><a href="#卸载WAS" class="headerlink" title="卸载WAS"></a>卸载WAS</h2><ol><li><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img9.png" alt="WAS卸载截图">  </li><li><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img10.png" alt="WAS卸载截图">  </li><li><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img11.png" alt="WAS卸载截图">  </li><li><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img12.png" alt="WAS卸载截图">  </li><li>删除WebSphere目录<br><img src="/2018/03/02/Ubuntu子系统安装Websphere8.5.5/../../../../img/WinUbuntu/img13.png" alt="WAS卸载截图"></li></ol><h2 id="卸载Installation-Manager"><a href="#卸载Installation-Manager" class="headerlink" title="卸载Installation Manager"></a>卸载Installation Manager</h2><ol><li>进入到<code>/opt/IBM/InstallationManager/eclipse/tools</code>目录下。</li><li>执行<code>./imcl listInstalledPackages</code>查看已安装的包。</li><li>执行<code>./imcl uninstall packageID</code>命令进行卸载。</li><li>Installation Manager 命令行 imcl 的命令和选项的更多信息参考如下链接：<br><a href="https://www.ibm.com/support/knowledgecenter/zh/SSDV2W_1.8.5/com.ibm.cic.commandline.doc/topics/r_tools_imcl.html" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/zh/SSDV2W_1.8.5/com.ibm.cic.commandline.doc/topics/r_tools_imcl.html</a></li></ol><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;前段时间通过Win10升级助手升级了最新的Win10系统，发现应用商店里居然有Linux子系统。本着好奇心就下载体验了下，省去了安装VMware虚拟机。&lt;/p&gt;
    
    </summary>
    
      <category term="其他" scheme="https://comlc.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
      <category term="开发环境" scheme="https://comlc.github.io/categories/%E5%85%B6%E4%BB%96/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    
    
      <category term="Ubuntu" scheme="https://comlc.github.io/tags/Ubuntu/"/>
    
      <category term="Websphere" scheme="https://comlc.github.io/tags/Websphere/"/>
    
  </entry>
  
</feed>
